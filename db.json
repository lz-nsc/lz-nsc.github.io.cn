{"meta":{"version":1,"warehouse":"4.0.0"},"models":{"Asset":[{"_id":"source/CNAME","path":"CNAME","modified":1,"renderable":0},{"_id":"source/img/Remove_heap.png","path":"img/Remove_heap.png","modified":1,"renderable":0},{"_id":"source/img/Fix_heap.png","path":"img/Fix_heap.png","modified":1,"renderable":0},{"_id":"source/img/author.png","path":"img/author.png","modified":1,"renderable":0},{"_id":"source/img/build_heap.png","path":"img/build_heap.png","modified":1,"renderable":0},{"_id":"source/img/logo.png","path":"img/logo.png","modified":1,"renderable":0},{"_id":"source/img/pop_heap.png","path":"img/pop_heap.png","modified":1,"renderable":0},{"_id":"source/img/push_heap.png","path":"img/push_heap.png","modified":1,"renderable":0},{"_id":"themes/kaze/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/main.js","path":"js/main.js","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/busuanzi.min.js","path":"js/lib/busuanzi.min.js","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/md5.min.js","path":"js/lib/md5.min.js","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/lozad.min.js","path":"js/lib/lozad.min.js","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/lightbox/baguetteBox.min.css","path":"js/lib/lightbox/baguetteBox.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-coy.min.css","path":"js/lib/prism/prism-coy.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-funky.min.css","path":"js/lib/prism/prism-funky.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-line-numbers.min.css","path":"js/lib/prism/prism-line-numbers.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-okaidia.min.css","path":"js/lib/prism/prism-okaidia.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/lightbox/baguetteBox.min.js","path":"js/lib/lightbox/baguetteBox.min.js","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-dark.min.css","path":"js/lib/prism/prism-dark.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-solarizedlight.min.css","path":"js/lib/prism/prism-solarizedlight.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-twilight.min.css","path":"js/lib/prism/prism-twilight.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism.min.css","path":"js/lib/prism/prism.min.css","modified":1,"renderable":1},{"_id":"themes/kaze/source/js/lib/prism/prism-tomorrow.min.css","path":"js/lib/prism/prism-tomorrow.min.css","modified":1,"renderable":1}],"Cache":[{"_id":"source/.DS_Store","hash":"db135c65e502db9f1ce2305fcb7dcd9dd5a2b418","modified":1650018119549},{"_id":"source/CNAME","hash":"a4b619a410ec0336815f206a275e9c8d3c6abcbc","modified":1650190203280},{"_id":"source/css/prettify.css","hash":"3f5dc3139f7385092d5dd567bb273c4585dee82d","modified":1650013416433},{"_id":"source/_posts/Kubernetes集群搭建.md","hash":"ae68a0d761f330fe45245066191b4703e3459d1f","modified":1650019446391},{"_id":"source/img/.DS_Store","hash":"f449fa99575e5427e60880aaab3893d2313df9a2","modified":1650018897393},{"_id":"source/js/prettify.js","hash":"eec92d79f0678b390289981b01866ea5dd36c090","modified":1650013416434},{"_id":"source/img/Remove_heap.png","hash":"70f8b120a7aef72c2edf3d49685380a60ce40a63","modified":1650005691557},{"_id":"source/img/build_heap.png","hash":"1fad7e66d526adf5a2371b2fc8c501bca4a0ae6a","modified":1649949152579},{"_id":"source/img/logo.png","hash":"c7f18e83104aaf6654d35f77a0c049bc7843f3c1","modified":1650019099790},{"_id":"source/img/push_heap.png","hash":"baa392e2411c4252b7a2b83f44ffd5fe440d1784","modified":1649952619307},{"_id":"source/img/pop_heap.png","hash":"f928f04e8e0e76ac6125553cf1d5c3646f5faa35","modified":1649949278899},{"_id":"source/img/Fix_heap.png","hash":"305e8c165b52a1f792e0c2df4a652f09e00381a8","modified":1649953491592},{"_id":"source/img/author.png","hash":"7d61c7225ebbe0928ce43a5235f413264b27b337","modified":1650018038547},{"_id":"themes/kaze/.eslintrc.json","hash":"d314cb34201cf92478080d73c4fb5ac979fbad88","modified":1650016261796},{"_id":"themes/kaze/README_zh.md","hash":"daf08c06161ae69043210f1321c35cf212d6cae9","modified":1650016261797},{"_id":"themes/kaze/LICENSE","hash":"f02809429223af6943d9ce48bcf9573c8bcd8d74","modified":1650016261797},{"_id":"themes/kaze/README.md","hash":"bbc5bf6f997b7961cbbd9f002bc75e82dff86a51","modified":1650016261797},{"_id":"themes/kaze/gulpfile.js","hash":"625872400c48d03fc0615c34f69747f8aacc61b2","modified":1650016261798},{"_id":"themes/kaze/_config.yml","hash":"3629f87d294f73fb33befb5a4727eace93941e5f","modified":1650188406385},{"_id":"themes/kaze/package.json","hash":"f544eecd06020aa26b36148c9dd856c73ee87dd0","modified":1650016261802},{"_id":"themes/kaze/index.js","hash":"dd954ff71b30613073ea85f0ebd2ceb4c90f33c2","modified":1650016261798},{"_id":"themes/kaze/languages/en.yml","hash":"d9967d04151a33e866b830b8d31c17efe379aef9","modified":1650016261798},{"_id":"themes/kaze/languages/zh-CN.yml","hash":"1651aa0c44429dfae90a4ab5889962353be1620e","modified":1650188417879},{"_id":"themes/kaze/languages/zh-TW.yml","hash":"6d3c1b7e5a43b3d15538e43a93ab1934afc6b5be","modified":1650016261798},{"_id":"themes/kaze/layout/about.ejs","hash":"2d2014df369fb26b3b4a277b91aeb40ec8b6abc5","modified":1650016261801},{"_id":"themes/kaze/layout/artitalk.ejs","hash":"b732a3bf354231d5fcb19b69e1dd66b8b8bb33a7","modified":1650016261801},{"_id":"themes/kaze/layout/archive.ejs","hash":"ae65373c8b6fb6732ec6618e19f40add5ec36597","modified":1650016261801},{"_id":"themes/kaze/layout/category.ejs","hash":"ede20874bedbeb68490f9575448b7b3ec66fa614","modified":1650016261801},{"_id":"themes/kaze/layout/layout.ejs","hash":"f0d09b15b25afa937f05d2fd4a6cc12d5f02c1fe","modified":1650016261801},{"_id":"themes/kaze/layout/categories.ejs","hash":"8e8c0ad6be14a25531e38a2d36c119bce8634593","modified":1650016261801},{"_id":"themes/kaze/layout/index.ejs","hash":"065ee8a03c816686a210d731d7b5473afb57388f","modified":1650016261801},{"_id":"themes/kaze/layout/links.ejs","hash":"37c95b357163058d7d86c8a1c1df140118c8cb20","modified":1650016261801},{"_id":"themes/kaze/layout/post.ejs","hash":"d4a365bc7c6055d451a69507b6cd9b2d6a0da98a","modified":1650016261802},{"_id":"themes/kaze/layout/tags.ejs","hash":"cc2e04a4490450c12851b6a071da8a3c2389f51e","modified":1650016261802},{"_id":"themes/kaze/layout/tag.ejs","hash":"7a75c500dc1dc75255250928d5fd78b38acd0d30","modified":1650016261802},{"_id":"themes/kaze/lib/mergeConfig.js","hash":"a14df30e68accd8c074bf8e2e1d35b610152cc55","modified":1650016261802},{"_id":"themes/kaze/lib/lazyload.js","hash":"4d261bc1285fde791d77f3ed1b4369a0cd27c9a5","modified":1650016261802},{"_id":"themes/kaze/scripts/index.js","hash":"8b132ba169a658a7196a47f4635b6b0029c8b0ab","modified":1650016261803},{"_id":"themes/kaze/layout/_partial/archives.ejs","hash":"173741393cce664c03e17244cb54d7eb63955b23","modified":1650016261798},{"_id":"themes/kaze/layout/_partial/categories.ejs","hash":"c5b749ce7cf0da7005add833812036704ed1734e","modified":1650016261798},{"_id":"themes/kaze/layout/_partial/author.ejs","hash":"55f5dce2bdbfea76ad1b7a9f9f3abd64838d22d8","modified":1650016261798},{"_id":"themes/kaze/layout/_partial/footer.ejs","hash":"635a6e8caded1f03e7c859da342a21b82aa60f2a","modified":1650016261798},{"_id":"themes/kaze/layout/_partial/left-aside.ejs","hash":"900513dfe4aec40892ab4139d0762dc2d1273aad","modified":1650016261799},{"_id":"themes/kaze/layout/_partial/head.ejs","hash":"537117a906bf2ad339faaeaccf71e0d068947271","modified":1650016261799},{"_id":"themes/kaze/layout/_partial/nav.ejs","hash":"14ae1dc1487b9db36439a5cc7e4a61c663b9cd45","modified":1650016261799},{"_id":"themes/kaze/layout/_partial/recent-post.ejs","hash":"50b5b07f1ccbcf7582e16e16776e3174fd8d2121","modified":1650016261800},{"_id":"themes/kaze/layout/_partial/pagination.ejs","hash":"42b0f7653c01b1a519502435bdfb94e871427119","modified":1650016261799},{"_id":"themes/kaze/layout/_partial/scrollbutton.ejs","hash":"35e1fc6030be7f4b85f3779f48e6a54da7c8d88a","modified":1650016261800},{"_id":"themes/kaze/layout/_partial/right-aside.ejs","hash":"bd6dbfc07cae0f757fa010bf39342c374e492db6","modified":1650016261800},{"_id":"themes/kaze/layout/_partial/tags.ejs","hash":"1e787adc2f71274a5f1a46a6e48949ddc9e3975f","modified":1650016261800},{"_id":"themes/kaze/layout/_partial/toc-card.ejs","hash":"c7851ba3b79c51cde0aa86c1ef00f218eb6b9023","modified":1650016261800},{"_id":"themes/kaze/lib/minify/minifyCSS.js","hash":"a05c5435db2d7a8dc2750e6b684457a867451aa6","modified":1650016261802},{"_id":"themes/kaze/lib/minify/minifyHTML.js","hash":"9fea2e1cf2b3b0a66091ae2d7c029b8b64659329","modified":1650016261802},{"_id":"themes/kaze/lib/minify/minifyJS.js","hash":"821cd069e2f36d9e18a7735b1cd29ceb8c9fe213","modified":1650016261802},{"_id":"themes/kaze/scripts/generators/pagerouter.js","hash":"ff9ad130a6b55b73d66d13233d2acb078a416bb8","modified":1650016261803},{"_id":"themes/kaze/scripts/generators/search.js","hash":"e99f4770ca2c8383f8710f0cf94b45d3ac522de4","modified":1650016261803},{"_id":"themes/kaze/scripts/helpers/count.js","hash":"a2ecc582e9f4489726bb9668b51b682f8129e30e","modified":1650016261803},{"_id":"themes/kaze/scripts/helpers/load.js","hash":"f4bb1a926a428b2b8162389e85ac1679aa0dc0e7","modified":1650016261803},{"_id":"themes/kaze/scripts/highlight/replace.js","hash":"38879d7e4bafd016a0a3cd86df65233eb2d0f92e","modified":1650016261803},{"_id":"themes/kaze/scripts/tag/note.js","hash":"a04695ac1c623544a554b083b2bb112caaeb571f","modified":1650016261803},{"_id":"themes/kaze/source/css/main.styl","hash":"8b602110e32636076754d9e26555f4c924dfa8bb","modified":1650016261807},{"_id":"themes/kaze/source/js/main.js","hash":"af2857830858fc387588bafa19d8c301af9f4cc4","modified":1650016261809},{"_id":"themes/kaze/src/scripts/darkMode.ts","hash":"617cd91f784e02ec56c65ac891e67e047a417424","modified":1650016261809},{"_id":"themes/kaze/src/scripts/console.ts","hash":"166f8b5784ed4a491b562686bb6a4989b3f5cb1f","modified":1650016261809},{"_id":"themes/kaze/src/scripts/menuButton.ts","hash":"c0241bd5e9b9d15f5e30093551e289420f238264","modified":1650016261810},{"_id":"themes/kaze/src/scripts/index.d.ts","hash":"60fd280abf38dd67307f9762e412435616f270a3","modified":1650016261809},{"_id":"themes/kaze/src/scripts/popButton.ts","hash":"364fc79bb94bb81b8748eb592cd3e47b9863a893","modified":1650016261810},{"_id":"themes/kaze/src/scripts/rollup.config.js","hash":"36b8bc73ec46b28a9609a1327cb7f06802d811c7","modified":1650016261810},{"_id":"themes/kaze/src/scripts/main.ts","hash":"4b670650515888233deb6966cb80a8acf692513d","modified":1650016261810},{"_id":"themes/kaze/src/scripts/scrollUp.ts","hash":"ada39508cc613b4f1e60c0d193a2e9c7d496e5ff","modified":1650016261810},{"_id":"themes/kaze/src/scripts/tsconfig.json","hash":"f4110da2308efcddb75d588aa7859391488bf259","modified":1650016261811},{"_id":"themes/kaze/src/scripts/search.ts","hash":"567255f06efe7d146304e1f5af6553ea2f315325","modified":1650016261811},{"_id":"themes/kaze/layout/_partial/plugins/latex.ejs","hash":"5c833ab8d605837080647f59826511605b1c55ec","modified":1650016261800},{"_id":"themes/kaze/layout/_partial/plugins/lightbox.ejs","hash":"55f62cd29ef9f9320b1280deb7a46042e61de13f","modified":1650016261800},{"_id":"themes/kaze/source/css/_base/highlight.styl","hash":"466974079c5f2cedc89e5ffa65b79beefe1d521b","modified":1650016261804},{"_id":"themes/kaze/source/css/_base/index.styl","hash":"c5eb9ee07af5825d919504fd55acaf7c74f92edc","modified":1650016261804},{"_id":"themes/kaze/source/css/_base/reset.styl","hash":"235d6d0dc47ee6be3d5b1cb3130fd1b4dac5a54e","modified":1650016261804},{"_id":"themes/kaze/source/css/_base/color.styl","hash":"79422f2777a4b945bd526214e013b1d4d094b92e","modified":1650016261804},{"_id":"themes/kaze/source/css/_mixins/index.styl","hash":"1a7b903c2a2efac8b00f5cc8d66efcf0815e4f0f","modified":1650016261804},{"_id":"themes/kaze/source/css/_pages/categories.styl","hash":"eb6b59a69b3e0e5f8308f78a3ab2a76315421c94","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/about.styl","hash":"77b652d7f4df3070f9ad914bfde737dd17136698","modified":1650016261804},{"_id":"themes/kaze/source/css/_pages/archives.styl","hash":"a16f9c95bbb35e0f40b4a13dea289bce5cdbc888","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/index.styl","hash":"9cf3eaefe00fadd82226ed0b934008236c212564","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/rewrite.styl","hash":"ff11ffb307b13eedbeb6d8646fc8857d1df8472a","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/tags.styl","hash":"fd982b1929796ccea7b9e58297335998b310c894","modified":1650016261805},{"_id":"themes/kaze/source/css/_variables/index.styl","hash":"aa5ecdeae5d29c86ca257e186feadb1e8c22b4b0","modified":1650016261807},{"_id":"themes/kaze/source/js/lib/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1650016261807},{"_id":"themes/kaze/source/js/lib/md5.min.js","hash":"ab074f76aa161e2851e19733d802a66c9a242387","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/lozad.min.js","hash":"31d6033296c6e6ebff829ab29d171bac3177280d","modified":1650016261808},{"_id":"themes/kaze/layout/_partial/plugins/comments/gitalk.ejs","hash":"01e8ca5073c131ffed9d23ea87473824a4baab09","modified":1650016261799},{"_id":"themes/kaze/layout/_partial/plugins/comments/livere.ejs","hash":"83290804d1f28b3ab9762ada814cf4815bcf24a2","modified":1650016261799},{"_id":"themes/kaze/source/css/_pages/widgets/archive.styl","hash":"ad5f4c28411e2054c14003f723c7732682899813","modified":1650016261805},{"_id":"themes/kaze/layout/_partial/plugins/comments/valine.ejs","hash":"11f9ec64783d78486ef4d07150a35ec9fc0e04e4","modified":1650016261799},{"_id":"themes/kaze/source/css/_pages/widgets/button.styl","hash":"732e595a17701ddd307ca56d2d77b2f336feae8d","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/widgets/author.styl","hash":"0ce572fa59c298f3a071b81f33a86c4dc5a044cc","modified":1650016261805},{"_id":"themes/kaze/layout/_partial/plugins/comments/waline.ejs","hash":"024e79be1f9f5fe2612bd35fa71cd1f7d8b531fe","modified":1650016261799},{"_id":"themes/kaze/source/css/_pages/widgets/categories.styl","hash":"6e600621b9610b20636ec158fe95d8526e9c7904","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/widgets/container.styl","hash":"62faf1e412d9b7d5d709ad6619df36f5991d1ef4","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/card.styl","hash":"db2b18162ce44bce7b7a6ef4a9c6a0d47ff4003e","modified":1650016261805},{"_id":"themes/kaze/source/css/_pages/widgets/columns.styl","hash":"0dce9e38b8ee4a3aae49b2b978859b01f132bf5f","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/footer.styl","hash":"fe93d15bfd0d0fbb6fd4e7fc4e6634e6564f5382","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/friends.styl","hash":"3ad6e00b1913043157d8568de2b3de951cabfd6e","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/nav.styl","hash":"eb4a6a66f3c2629e3a31ec18deb2463e2feb9822","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/pagination.styl","hash":"87787a0ac9863dc2ef4647e665dc7723116af9c6","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/post.styl","hash":"fdb9b1c4163746a0858f7a60c59531dc0b6c4a1f","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/postlist.styl","hash":"8dd8f1c8e10f28f7895635f26d7269b01f7f60d5","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/recentposts.styl","hash":"4dc019947948744c5d180444a8f342a7988c6d37","modified":1650016261806},{"_id":"themes/kaze/source/css/_pages/widgets/search.styl","hash":"ef81b98cef1f47da1381df0a6d47cbd4fcac3e4b","modified":1650016261807},{"_id":"themes/kaze/source/css/_pages/widgets/section.styl","hash":"61e7d629d2f124c9f6099134fa674fe7505f415d","modified":1650016261807},{"_id":"themes/kaze/source/css/_pages/widgets/tags.styl","hash":"c3a33c7f1e6453f12cbb691f1d63e0b474534954","modified":1650016261807},{"_id":"themes/kaze/source/css/_pages/widgets/toc.styl","hash":"c353b845bfd881de34d3dd1326edd213980af0fa","modified":1650016261807},{"_id":"themes/kaze/source/js/lib/lightbox/baguetteBox.min.css","hash":"4daa164702723f5206591005151dc89f58eab559","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-coy.min.css","hash":"de43e5d8fe8ac0e5be493fc37280a14764d224ba","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-funky.min.css","hash":"1b4f667352bde11377b82f6402af9470ca7d410d","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-line-numbers.min.css","hash":"7831e69297d5fadf91f33f63f2aeb58f0c374e6b","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-okaidia.min.css","hash":"a611beee4ccd9bc303667159ad2977fc4fa02126","modified":1650016261809},{"_id":"themes/kaze/source/js/lib/lightbox/baguetteBox.min.js","hash":"300d6a58c385a454ac7f6b271e210ab59f54796c","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-dark.min.css","hash":"99ad7013f4e2cb94d6858f1d338ce24976722e16","modified":1650016261808},{"_id":"themes/kaze/source/js/lib/prism/prism-solarizedlight.min.css","hash":"58ddae9f0df85468118a028e24b975848e22488c","modified":1650016261809},{"_id":"themes/kaze/source/js/lib/prism/prism-twilight.min.css","hash":"18a27c7ef76965a40daaab90035500a3ad7f2cbf","modified":1650016261809},{"_id":"themes/kaze/source/js/lib/prism/prism.min.css","hash":"3e748cee6ef8cdaceec5335971b8d133aa9dcfa3","modified":1650016261809},{"_id":"themes/kaze/source/js/lib/prism/prism-tomorrow.min.css","hash":"ff9820d63a78827b2798030c4734e9c752183953","modified":1650016261809},{"_id":"public/css/prettify.css","hash":"3f5dc3139f7385092d5dd567bb273c4585dee82d","modified":1650191023890},{"_id":"public/js/prettify.js","hash":"3b051f17caf79fc156c908090c17e5d2469fbe4d","modified":1650191023890},{"_id":"public/atom.xml","hash":"539c4fd71ced9b0f1ebda2be52474cbee7d75b90","modified":1650191023890},{"_id":"public/sitemap.xml","hash":"c839b531a09f364ef7b8f6a9ba512873eae55c84","modified":1650191023890},{"_id":"public/archives/2021/index.html","hash":"64757faf201f5a38c217424e6a8c474a6cd7cde8","modified":1650191023890},{"_id":"public/archives/index.html","hash":"0076f25281ee678e3d0529677d424e114ce25ef5","modified":1650191023890},{"_id":"public/archives/2021/09/index.html","hash":"931052a8dd2b1f080c8cb6907433fe4e954d4d39","modified":1650191023890},{"_id":"public/tags/Kubernetes/index.html","hash":"179ca011f85ff99316a31a12e64f485619b0cf9d","modified":1650191023890},{"_id":"public/index.html","hash":"9d64d79fde4786d583a60280cfb6517f1260d554","modified":1650191023890},{"_id":"public/categories/index.html","hash":"c3b7e171dd5f1eb268f66c88db310137e184ff0b","modified":1650191023890},{"_id":"public/tags/index.html","hash":"f8f4efe5fd94b800457d8f572c464d2c04a6d6be","modified":1650191023890},{"_id":"public/2021/09/14/Kubernetes集群搭建/index.html","hash":"8ca635413632dba443207b63f1410faabb943dad","modified":1650191023890},{"_id":"public/links/index.html","hash":"c9998e3278ea6acc3b45f37718b2a1fe9ae4f322","modified":1650191023890},{"_id":"public/CNAME","hash":"a4b619a410ec0336815f206a275e9c8d3c6abcbc","modified":1650191023890},{"_id":"public/img/Remove_heap.png","hash":"70f8b120a7aef72c2edf3d49685380a60ce40a63","modified":1650191023890},{"_id":"public/img/build_heap.png","hash":"1fad7e66d526adf5a2371b2fc8c501bca4a0ae6a","modified":1650191023890},{"_id":"public/img/pop_heap.png","hash":"f928f04e8e0e76ac6125553cf1d5c3646f5faa35","modified":1650191023890},{"_id":"public/img/logo.png","hash":"c7f18e83104aaf6654d35f77a0c049bc7843f3c1","modified":1650191023890},{"_id":"public/img/push_heap.png","hash":"baa392e2411c4252b7a2b83f44ffd5fe440d1784","modified":1650191023890},{"_id":"public/img/Fix_heap.png","hash":"305e8c165b52a1f792e0c2df4a652f09e00381a8","modified":1650191023890},{"_id":"public/js/main.js","hash":"af2857830858fc387588bafa19d8c301af9f4cc4","modified":1650191023890},{"_id":"public/js/lib/busuanzi.min.js","hash":"6e41f31100ae7eb3a6f23f2c168f6dd56e7f7a9a","modified":1650191023890},{"_id":"public/js/lib/md5.min.js","hash":"ab074f76aa161e2851e19733d802a66c9a242387","modified":1650191023890},{"_id":"public/js/lib/lozad.min.js","hash":"31d6033296c6e6ebff829ab29d171bac3177280d","modified":1650191023890},{"_id":"public/js/lib/lightbox/baguetteBox.min.css","hash":"4daa164702723f5206591005151dc89f58eab559","modified":1650191023890},{"_id":"public/js/lib/prism/prism-coy.min.css","hash":"de43e5d8fe8ac0e5be493fc37280a14764d224ba","modified":1650191023890},{"_id":"public/js/lib/prism/prism-line-numbers.min.css","hash":"7831e69297d5fadf91f33f63f2aeb58f0c374e6b","modified":1650191023890},{"_id":"public/js/lib/prism/prism-funky.min.css","hash":"1b4f667352bde11377b82f6402af9470ca7d410d","modified":1650191023890},{"_id":"public/js/lib/prism/prism-okaidia.min.css","hash":"a611beee4ccd9bc303667159ad2977fc4fa02126","modified":1650191023890},{"_id":"public/js/lib/lightbox/baguetteBox.min.js","hash":"300d6a58c385a454ac7f6b271e210ab59f54796c","modified":1650191023890},{"_id":"public/js/lib/prism/prism-dark.min.css","hash":"99ad7013f4e2cb94d6858f1d338ce24976722e16","modified":1650191023890},{"_id":"public/js/lib/prism/prism-solarizedlight.min.css","hash":"58ddae9f0df85468118a028e24b975848e22488c","modified":1650191023890},{"_id":"public/js/lib/prism/prism.min.css","hash":"3e748cee6ef8cdaceec5335971b8d133aa9dcfa3","modified":1650191023890},{"_id":"public/js/lib/prism/prism-twilight.min.css","hash":"18a27c7ef76965a40daaab90035500a3ad7f2cbf","modified":1650191023890},{"_id":"public/js/lib/prism/prism-tomorrow.min.css","hash":"ff9820d63a78827b2798030c4734e9c752183953","modified":1650191023890},{"_id":"public/css/main.css","hash":"5e9ac7c138b6e510f02518e8e01366b3b74cb794","modified":1650191023890},{"_id":"public/img/author.png","hash":"7d61c7225ebbe0928ce43a5235f413264b27b337","modified":1650191023890}],"Category":[],"Data":[],"Page":[{"_content":"/**\n * @license\n * Copyright (C) 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Pretty printing styles. Used with prettify.js. */\n\n\n/* SPAN elements with the classes below are added by prettyprint. */\n.pln { color: #000 }  /* plain text */\n\n@media screen {\n  .str { color: #080 }  /* string content */\n  .kwd { color: #008 }  /* a keyword */\n  .com { color: #800 }  /* a comment */\n  .typ { color: #606 }  /* a type name */\n  .lit { color: #066 }  /* a literal value */\n  /* punctuation, lisp open bracket, lisp close bracket */\n  .pun, .opn, .clo { color: #660 }\n  .tag { color: #008 }  /* a markup tag name */\n  .atn { color: #606 }  /* a markup attribute name */\n  .atv { color: #080 }  /* a markup attribute value */\n  .dec, .var { color: #606 }  /* a declaration; a variable name */\n  .fun { color: red }  /* a function name */\n}\n\n/* Use higher contrast and text-weight for printable form. */\n@media print, projection {\n  .str { color: #060 }\n  .kwd { color: #006; font-weight: bold }\n  .com { color: #600; font-style: italic }\n  .typ { color: #404; font-weight: bold }\n  .lit { color: #044 }\n  .pun, .opn, .clo { color: #440 }\n  .tag { color: #006; font-weight: bold }\n  .atn { color: #404 }\n  .atv { color: #060 }\n}\n\n/* Put a border around prettyprinted code snippets. */\npre.prettyprint { padding: 2px; border: 1px solid #888 }\n\n/* Specify class=linenums on a pre to get line numbering */\nol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */\nli.L0,\nli.L1,\nli.L2,\nli.L3,\nli.L5,\nli.L6,\nli.L7,\nli.L8 { list-style-type: none }\n/* Alternate shading for lines */\nli.L1,\nli.L3,\nli.L5,\nli.L7,\nli.L9 { background: #eee }\n","source":"css/prettify.css","raw":"/**\n * @license\n * Copyright (C) 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Pretty printing styles. Used with prettify.js. */\n\n\n/* SPAN elements with the classes below are added by prettyprint. */\n.pln { color: #000 }  /* plain text */\n\n@media screen {\n  .str { color: #080 }  /* string content */\n  .kwd { color: #008 }  /* a keyword */\n  .com { color: #800 }  /* a comment */\n  .typ { color: #606 }  /* a type name */\n  .lit { color: #066 }  /* a literal value */\n  /* punctuation, lisp open bracket, lisp close bracket */\n  .pun, .opn, .clo { color: #660 }\n  .tag { color: #008 }  /* a markup tag name */\n  .atn { color: #606 }  /* a markup attribute name */\n  .atv { color: #080 }  /* a markup attribute value */\n  .dec, .var { color: #606 }  /* a declaration; a variable name */\n  .fun { color: red }  /* a function name */\n}\n\n/* Use higher contrast and text-weight for printable form. */\n@media print, projection {\n  .str { color: #060 }\n  .kwd { color: #006; font-weight: bold }\n  .com { color: #600; font-style: italic }\n  .typ { color: #404; font-weight: bold }\n  .lit { color: #044 }\n  .pun, .opn, .clo { color: #440 }\n  .tag { color: #006; font-weight: bold }\n  .atn { color: #404 }\n  .atv { color: #060 }\n}\n\n/* Put a border around prettyprinted code snippets. */\npre.prettyprint { padding: 2px; border: 1px solid #888 }\n\n/* Specify class=linenums on a pre to get line numbering */\nol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */\nli.L0,\nli.L1,\nli.L2,\nli.L3,\nli.L5,\nli.L6,\nli.L7,\nli.L8 { list-style-type: none }\n/* Alternate shading for lines */\nli.L1,\nli.L3,\nli.L5,\nli.L7,\nli.L9 { background: #eee }\n","date":"2022-04-15T09:03:36.433Z","updated":"2022-04-15T09:03:36.433Z","path":"css/prettify.css","layout":"false","title":"","comments":1,"_id":"cl2354nie00009eu70e15g150","content":"/**\n * @license\n * Copyright (C) 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Pretty printing styles. Used with prettify.js. */\n\n\n/* SPAN elements with the classes below are added by prettyprint. */\n.pln { color: #000 }  /* plain text */\n\n@media screen {\n  .str { color: #080 }  /* string content */\n  .kwd { color: #008 }  /* a keyword */\n  .com { color: #800 }  /* a comment */\n  .typ { color: #606 }  /* a type name */\n  .lit { color: #066 }  /* a literal value */\n  /* punctuation, lisp open bracket, lisp close bracket */\n  .pun, .opn, .clo { color: #660 }\n  .tag { color: #008 }  /* a markup tag name */\n  .atn { color: #606 }  /* a markup attribute name */\n  .atv { color: #080 }  /* a markup attribute value */\n  .dec, .var { color: #606 }  /* a declaration; a variable name */\n  .fun { color: red }  /* a function name */\n}\n\n/* Use higher contrast and text-weight for printable form. */\n@media print, projection {\n  .str { color: #060 }\n  .kwd { color: #006; font-weight: bold }\n  .com { color: #600; font-style: italic }\n  .typ { color: #404; font-weight: bold }\n  .lit { color: #044 }\n  .pun, .opn, .clo { color: #440 }\n  .tag { color: #006; font-weight: bold }\n  .atn { color: #404 }\n  .atv { color: #060 }\n}\n\n/* Put a border around prettyprinted code snippets. */\npre.prettyprint { padding: 2px; border: 1px solid #888 }\n\n/* Specify class=linenums on a pre to get line numbering */\nol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */\nli.L0,\nli.L1,\nli.L2,\nli.L3,\nli.L5,\nli.L6,\nli.L7,\nli.L8 { list-style-type: none }\n/* Alternate shading for lines */\nli.L1,\nli.L3,\nli.L5,\nli.L7,\nli.L9 { background: #eee }\n","site":{"data":{}},"excerpt":"","more":"/**\n * @license\n * Copyright (C) 2015 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/* Pretty printing styles. Used with prettify.js. */\n\n\n/* SPAN elements with the classes below are added by prettyprint. */\n.pln { color: #000 }  /* plain text */\n\n@media screen {\n  .str { color: #080 }  /* string content */\n  .kwd { color: #008 }  /* a keyword */\n  .com { color: #800 }  /* a comment */\n  .typ { color: #606 }  /* a type name */\n  .lit { color: #066 }  /* a literal value */\n  /* punctuation, lisp open bracket, lisp close bracket */\n  .pun, .opn, .clo { color: #660 }\n  .tag { color: #008 }  /* a markup tag name */\n  .atn { color: #606 }  /* a markup attribute name */\n  .atv { color: #080 }  /* a markup attribute value */\n  .dec, .var { color: #606 }  /* a declaration; a variable name */\n  .fun { color: red }  /* a function name */\n}\n\n/* Use higher contrast and text-weight for printable form. */\n@media print, projection {\n  .str { color: #060 }\n  .kwd { color: #006; font-weight: bold }\n  .com { color: #600; font-style: italic }\n  .typ { color: #404; font-weight: bold }\n  .lit { color: #044 }\n  .pun, .opn, .clo { color: #440 }\n  .tag { color: #006; font-weight: bold }\n  .atn { color: #404 }\n  .atv { color: #060 }\n}\n\n/* Put a border around prettyprinted code snippets. */\npre.prettyprint { padding: 2px; border: 1px solid #888 }\n\n/* Specify class=linenums on a pre to get line numbering */\nol.linenums { margin-top: 0; margin-bottom: 0 } /* IE indents via margin-left */\nli.L0,\nli.L1,\nli.L2,\nli.L3,\nli.L5,\nli.L6,\nli.L7,\nli.L8 { list-style-type: none }\n/* Alternate shading for lines */\nli.L1,\nli.L3,\nli.L5,\nli.L7,\nli.L9 { background: #eee }\n"},{"_content":"/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n/**\n * @typedef {!Array.<number|string>}\n * Alternating indices and the decorations that should be inserted there.\n * The indices are monotonically increasing.\n */\nvar DecorationsT;\n\n/**\n * @typedef {!{\n *   sourceNode: !Element,\n *   pre: !(number|boolean),\n *   langExtension: ?string,\n *   numberLines: ?(number|boolean),\n *   sourceCode: ?string,\n *   spans: ?(Array.<number|Node>),\n *   basePos: ?number,\n *   decorations: ?DecorationsT\n * }}\n * <dl>\n *  <dt>sourceNode<dd>the element containing the source\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>pre<dd>truthy if white-space in text nodes\n *     should be considered significant.\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. {@code <BR>}) corresponding to that\n *     span.\n *  <dt>decorations<dd>an array of style classes preceded\n *     by the position at which they start in job.sourceCode in order\n *  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n *     source.\n * </dl>\n */\nvar JobT;\n\n/**\n * @typedef {!{\n *   sourceCode: string,\n *   spans: !(Array.<number|Node>)\n * }}\n * <dl>\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. {@code <BR>}) corresponding to that\n *     span.\n * </dl>\n */\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = true;\n\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nvar PR_SHOULD_USE_CONTINUATION = true\nif (typeof window !== 'undefined') {\n  window['PR_SHOULD_USE_CONTINUATION'] = PR_SHOULD_USE_CONTINUATION;\n}\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = (typeof window !== 'undefined') ? window : {};\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,from,function,\" +\n      \"get,import,implements,instanceof,interface,let,null,of,set,undefined,\" +\n      \"var,with,yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n  // Regex pattern below is automatically generated by regexpPrecederPatterns.pl\n  // Do not modify, your changes will be erased.\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n\n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n\n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n\n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n\n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) { out.push('^'); }\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n\n      return parts.join('');\n    }\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n\n    walk(node);\n\n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName.toLowerCase()) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n","source":"js/prettify.js","raw":"/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>} tags in your source with\n *    {@code class=prettyprint.}\n *    You can also use the (html deprecated) {@code <xmp>} tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the {@code <pre>} or {@code <code>} element to specify the\n * language, as in {@code <pre class=\"prettyprint lang-java\">}.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n/**\n * @typedef {!Array.<number|string>}\n * Alternating indices and the decorations that should be inserted there.\n * The indices are monotonically increasing.\n */\nvar DecorationsT;\n\n/**\n * @typedef {!{\n *   sourceNode: !Element,\n *   pre: !(number|boolean),\n *   langExtension: ?string,\n *   numberLines: ?(number|boolean),\n *   sourceCode: ?string,\n *   spans: ?(Array.<number|Node>),\n *   basePos: ?number,\n *   decorations: ?DecorationsT\n * }}\n * <dl>\n *  <dt>sourceNode<dd>the element containing the source\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>pre<dd>truthy if white-space in text nodes\n *     should be considered significant.\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. {@code <BR>}) corresponding to that\n *     span.\n *  <dt>decorations<dd>an array of style classes preceded\n *     by the position at which they start in job.sourceCode in order\n *  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n *     source.\n * </dl>\n */\nvar JobT;\n\n/**\n * @typedef {!{\n *   sourceCode: string,\n *   spans: !(Array.<number|Node>)\n * }}\n * <dl>\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. {@code <BR>}) corresponding to that\n *     span.\n * </dl>\n */\nvar SourceSpansT;\n\n/** @define {boolean} */\nvar IN_GLOBAL_SCOPE = true;\n\n\n/**\n * {@type !{\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * }}\n * @const\n */\nvar PR;\n\n/**\n * Split {@code prettyPrint} into multiple timeouts so as not to interfere with\n * UI events.\n * If set to {@code false}, {@code prettyPrint()} is synchronous.\n */\nvar PR_SHOULD_USE_CONTINUATION = true\nif (typeof window !== 'undefined') {\n  window['PR_SHOULD_USE_CONTINUATION'] = PR_SHOULD_USE_CONTINUATION;\n}\n\n/**\n * Pretty print a chunk of code.\n * @param {string} sourceCodeHtml The HTML to pretty print.\n * @param {string} opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param {number|boolean} opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return {string} code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n * {@code class=prettyprint} and prettify them.\n *\n * @param {Function} opt_whenDone called when prettifying is done.\n * @param {HTMLElement|HTMLDocument} opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to {@code document.body}.\n */\nvar prettyPrint;\n\n\n(function () {\n  var win = (typeof window !== 'undefined') ? window : {};\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,from,function,\" +\n      \"get,import,implements,instanceof,interface,let,null,of,set,undefined,\" +\n      \"var,with,yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n  // Regex pattern below is automatically generated by regexpPrecederPatterns.pl\n  // Do not modify, your changes will be erased.\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|{|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n\n  /**\n   * Given a group of {@link RegExp}s, returns a {@code RegExp} that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param {Array.<RegExp>} regexs non multiline, non-global regexs.\n   * @return {RegExp} a global regex.\n   */\n  function combinePrefixPatterns(regexs) {\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.ignoreCase) {\n        ignoreCase = true;\n      } else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]{4}|\\\\x[0-9a-f]{2}|\\\\[^ux]/gi, ''))) {\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      }\n    }\n\n    var escapeCharToCodeUnit = {\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    };\n\n    function decodeEscape(charsetPart) {\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) {\n        return cc0;\n      }\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) {\n        return cc0;\n      } else if ('0' <= c1 && c1 <= '7') {\n        return parseInt(charsetPart.substring(1), 8);\n      } else if (c1 === 'u' || c1 === 'x') {\n        return parseInt(charsetPart.substring(2), 16);\n      } else {\n        return charsetPart.charCodeAt(1);\n      }\n    }\n\n    function encodeEscape(charCode) {\n      if (charCode < 0x20) {\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      }\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    }\n\n    function caseFoldCharset(charSet) {\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]{4}'\n              + '|\\\\\\\\x[0-9A-Fa-f]{2}'\n              + '|\\\\\\\\[0-3][0-7]{0,2}'\n              + '|\\\\\\\\[0-7]{1,2}'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) { out.push('^'); }\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) {\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) {  // Don't muck with named groups.\n          out.push(p);\n        } else {\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) {\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          } else {\n            end = start;\n          }\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) {\n            if (!(end < 65 || start > 90)) {\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            }\n            if (!(end < 97 || start > 122)) {\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            }\n          }\n        }\n      }\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) { return (a[0] - b[0]) || (b[1]  - a[1]); });\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) {\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) {\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        } else {\n          consolidatedRanges.push(lastRange = range);\n        }\n      }\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) {\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) {\n          if (range[1] + 1 > range[0]) { out.push('-'); }\n          out.push(encodeEscape(range[1]));\n        }\n      }\n      out.push(']');\n      return out.join('');\n    }\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) {\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]{4}'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]{2}'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue) {\n            if (decimalValue <= groupIndex) {\n              capturedGroups[decimalValue] = -1;\n            } else {\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            }\n          }\n        }\n      }\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) {\n        if (-1 === capturedGroups[i]) {\n          capturedGroups[i] = ++capturedGroupIndex;\n        }\n      }\n      for (var i = 0, groupIndex = 0; i < n; ++i) {\n        var p = parts[i];\n        if (p === '(') {\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) {\n            parts[i] = '(?:';\n          }\n        } else if ('\\\\' === p.charAt(0)) {\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) {\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          }\n        }\n      }\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) {\n        if ('^' === parts[i] && '^' !== parts[i + 1]) { parts[i] = ''; }\n      }\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) {\n        for (var i = 0; i < n; ++i) {\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') {\n            parts[i] = caseFoldCharset(p);\n          } else if (ch0 !== '\\\\') {\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) {\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                });\n          }\n        }\n      }\n\n      return parts.join('');\n    }\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) {\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) { throw new Error('' + regex); }\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    }\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  }\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * {@code <p><b>print </b>'Hello '<br>  + 'World';</p>}.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * {\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * }\n   * </pre>\n   * <p>\n   * where #1 is a reference to the {@code \"print \"} text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The {@code} spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param {Node} node an HTML DOM subtree containing source-code.\n   * @param {boolean|number} isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return {SourceSpansT} source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1) {  // Element\n        if (nocode.test(node.className)) { return; }\n        for (var child = node.firstChild; child; child = child.nextSibling) {\n          walk(child);\n        }\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) {\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        }\n      } else if (type == 3 || type == 4) {  // Text\n        var text = node.nodeValue;\n        if (text.length) {\n          if (!isPreformatted) {\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          } else {\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          }\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        }\n      }\n    }\n\n    walk(node);\n\n    return {\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    };\n  }\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param {!Element} sourceNode\n   * @param {number} basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param {string} sourceCode\n   * @param {function(JobT)} langHandler\n   * @param {DecorationsT} out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) {\n    if (!sourceCode) { return; }\n    /** @type {JobT} */\n    var job = {\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    };\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  }\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in {@code <pre><code ...>} when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in {@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo {#}\n      // {#}\n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName.toLowerCase()) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n","date":"2022-04-15T09:03:36.434Z","updated":"2022-04-15T09:03:36.434Z","path":"js/prettify.js","layout":"false","title":"","comments":1,"_id":"cl2354nii00029eu74hh21vkp","content":"/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>&#125; tags in your source with\n *    &#123;@code class=prettyprint.&#125;\n *    You can also use the (html deprecated) &#123;@code <xmp>&#125; tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the &#123;@code <pre>&#125; or &#123;@code <code>&#125; element to specify the\n * language, as in &#123;@code <pre class=\"prettyprint lang-java\">&#125;.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n/**\n * @typedef &#123;!Array.<number|string>&#125;\n * Alternating indices and the decorations that should be inserted there.\n * The indices are monotonically increasing.\n */\nvar DecorationsT;\n\n/**\n * @typedef &#123;!&#123;\n *   sourceNode: !Element,\n *   pre: !(number|boolean),\n *   langExtension: ?string,\n *   numberLines: ?(number|boolean),\n *   sourceCode: ?string,\n *   spans: ?(Array.<number|Node>),\n *   basePos: ?number,\n *   decorations: ?DecorationsT\n * &#125;&#125;\n * <dl>\n *  <dt>sourceNode<dd>the element containing the source\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>pre<dd>truthy if white-space in text nodes\n *     should be considered significant.\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. &#123;@code <BR>&#125;) corresponding to that\n *     span.\n *  <dt>decorations<dd>an array of style classes preceded\n *     by the position at which they start in job.sourceCode in order\n *  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n *     source.\n * </dl>\n */\nvar JobT;\n\n/**\n * @typedef &#123;!&#123;\n *   sourceCode: string,\n *   spans: !(Array.<number|Node>)\n * &#125;&#125;\n * <dl>\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. &#123;@code <BR>&#125;) corresponding to that\n *     span.\n * </dl>\n */\nvar SourceSpansT;\n\n/** @define &#123;boolean&#125; */\nvar IN_GLOBAL_SCOPE = true;\n\n\n/**\n * &#123;@type !&#123;\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * &#125;&#125;\n * @const\n */\nvar PR;\n\n/**\n * Split &#123;@code prettyPrint&#125; into multiple timeouts so as not to interfere with\n * UI events.\n * If set to &#123;@code false&#125;, &#123;@code prettyPrint()&#125; is synchronous.\n */\nvar PR_SHOULD_USE_CONTINUATION = true\nif (typeof window !== 'undefined') &#123;\n  window['PR_SHOULD_USE_CONTINUATION'] = PR_SHOULD_USE_CONTINUATION;\n&#125;\n\n/**\n * Pretty print a chunk of code.\n * @param &#123;string&#125; sourceCodeHtml The HTML to pretty print.\n * @param &#123;string&#125; opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param &#123;number|boolean&#125; opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return &#123;string&#125; code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the &#123;@code <pre>&#125; and &#123;@code <code>&#125; tags in the DOM with\n * &#123;@code class=prettyprint&#125; and prettify them.\n *\n * @param &#123;Function&#125; opt_whenDone called when prettifying is done.\n * @param &#123;HTMLElement|HTMLDocument&#125; opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to &#123;@code document.body&#125;.\n */\nvar prettyPrint;\n\n\n(function () &#123;\n  var win = (typeof window !== 'undefined') ? window : &#123;&#125;;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,from,function,\" +\n      \"get,import,implements,instanceof,interface,let,null,of,set,undefined,\" +\n      \"var,with,yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n  // Regex pattern below is automatically generated by regexpPrecederPatterns.pl\n  // Do not modify, your changes will be erased.\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|&#123;|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n\n  /**\n   * Given a group of &#123;@link RegExp&#125;s, returns a &#123;@code RegExp&#125; that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param &#123;Array.<RegExp>&#125; regexs non multiline, non-global regexs.\n   * @return &#123;RegExp&#125; a global regex.\n   */\n  function combinePrefixPatterns(regexs) &#123;\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) &#123;\n      var regex = regexs[i];\n      if (regex.ignoreCase) &#123;\n        ignoreCase = true;\n      &#125; else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]&#123;4&#125;|\\\\x[0-9a-f]&#123;2&#125;|\\\\[^ux]/gi, ''))) &#123;\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      &#125;\n    &#125;\n\n    var escapeCharToCodeUnit = &#123;\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    &#125;;\n\n    function decodeEscape(charsetPart) &#123;\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) &#123;\n        return cc0;\n      &#125;\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) &#123;\n        return cc0;\n      &#125; else if ('0' <= c1 && c1 <= '7') &#123;\n        return parseInt(charsetPart.substring(1), 8);\n      &#125; else if (c1 === 'u' || c1 === 'x') &#123;\n        return parseInt(charsetPart.substring(2), 16);\n      &#125; else &#123;\n        return charsetPart.charCodeAt(1);\n      &#125;\n    &#125;\n\n    function encodeEscape(charCode) &#123;\n      if (charCode < 0x20) &#123;\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      &#125;\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    &#125;\n\n    function caseFoldCharset(charSet) &#123;\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]&#123;4&#125;'\n              + '|\\\\\\\\x[0-9A-Fa-f]&#123;2&#125;'\n              + '|\\\\\\\\[0-3][0-7]&#123;0,2&#125;'\n              + '|\\\\\\\\[0-7]&#123;1,2&#125;'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) &#123; out.push('^'); &#125;\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) &#123;\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) &#123;  // Don't muck with named groups.\n          out.push(p);\n        &#125; else &#123;\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) &#123;\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          &#125; else &#123;\n            end = start;\n          &#125;\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) &#123;\n            if (!(end < 65 || start > 90)) &#123;\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            &#125;\n            if (!(end < 97 || start > 122)) &#123;\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) &#123; return (a[0] - b[0]) || (b[1]  - a[1]); &#125;);\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) &#123;\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) &#123;\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        &#125; else &#123;\n          consolidatedRanges.push(lastRange = range);\n        &#125;\n      &#125;\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) &#123;\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) &#123;\n          if (range[1] + 1 > range[0]) &#123; out.push('-'); &#125;\n          out.push(encodeEscape(range[1]));\n        &#125;\n      &#125;\n      out.push(']');\n      return out.join('');\n    &#125;\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) &#123;\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]&#123;4&#125;'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]&#123;2&#125;'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) &#123;\n        var p = parts[i];\n        if (p === '(') &#123;\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        &#125; else if ('\\\\' === p.charAt(0)) &#123;\n          var decimalValue = +p.substring(1);\n          if (decimalValue) &#123;\n            if (decimalValue <= groupIndex) &#123;\n              capturedGroups[decimalValue] = -1;\n            &#125; else &#123;\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) &#123;\n        if (-1 === capturedGroups[i]) &#123;\n          capturedGroups[i] = ++capturedGroupIndex;\n        &#125;\n      &#125;\n      for (var i = 0, groupIndex = 0; i < n; ++i) &#123;\n        var p = parts[i];\n        if (p === '(') &#123;\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) &#123;\n            parts[i] = '(?:';\n          &#125;\n        &#125; else if ('\\\\' === p.charAt(0)) &#123;\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) &#123;\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          &#125;\n        &#125;\n      &#125;\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) &#123;\n        if ('^' === parts[i] && '^' !== parts[i + 1]) &#123; parts[i] = ''; &#125;\n      &#125;\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) &#123;\n        for (var i = 0; i < n; ++i) &#123;\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') &#123;\n            parts[i] = caseFoldCharset(p);\n          &#125; else if (ch0 !== '\\\\') &#123;\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) &#123;\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                &#125;);\n          &#125;\n        &#125;\n      &#125;\n\n      return parts.join('');\n    &#125;\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) &#123;\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) &#123; throw new Error('' + regex); &#125;\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    &#125;\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  &#125;\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * &#123;@code <p><b>print </b>'Hello '<br>  + 'World';</p>&#125;.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * &#123;\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * &#125;\n   * </pre>\n   * <p>\n   * where #1 is a reference to the &#123;@code \"print \"&#125; text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The &#123;@code&#125; spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param &#123;Node&#125; node an HTML DOM subtree containing source-code.\n   * @param &#123;boolean|number&#125; isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return &#123;SourceSpansT&#125; source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) &#123;\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) &#123;\n      var type = node.nodeType;\n      if (type == 1) &#123;  // Element\n        if (nocode.test(node.className)) &#123; return; &#125;\n        for (var child = node.firstChild; child; child = child.nextSibling) &#123;\n          walk(child);\n        &#125;\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) &#123;\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        &#125;\n      &#125; else if (type == 3 || type == 4) &#123;  // Text\n        var text = node.nodeValue;\n        if (text.length) &#123;\n          if (!isPreformatted) &#123;\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          &#125; else &#123;\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          &#125;\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        &#125;\n      &#125;\n    &#125;\n\n    walk(node);\n\n    return &#123;\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    &#125;;\n  &#125;\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param &#123;!Element&#125; sourceNode\n   * @param &#123;number&#125; basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param &#123;string&#125; sourceCode\n   * @param &#123;function(JobT)&#125; langHandler\n   * @param &#123;DecorationsT&#125; out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) &#123;\n    if (!sourceCode) &#123; return; &#125;\n    /** @type &#123;JobT&#125; */\n    var job = &#123;\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    &#125;;\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  &#125;\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in &#123;@code <pre><code ...>&#125; when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in &#123;@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo \n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName.toLowerCase()) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n","site":{"data":{}},"excerpt":"","more":"/**\n * @license\n * Copyright (C) 2006 Google Inc.\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *      http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\n/**\n * @fileoverview\n * some functions for browser-side pretty printing of code contained in html.\n *\n * <p>\n * For a fairly comprehensive set of languages see the\n * <a href=\"https://github.com/google/code-prettify#for-which-languages-does-it-work\">README</a>\n * file that came with this source.  At a minimum, the lexer should work on a\n * number of languages including C and friends, Java, Python, Bash, SQL, HTML,\n * XML, CSS, Javascript, and Makefiles.  It works passably on Ruby, PHP and Awk\n * and a subset of Perl, but, because of commenting conventions, doesn't work on\n * Smalltalk, Lisp-like, or CAML-like languages without an explicit lang class.\n * <p>\n * Usage: <ol>\n * <li> include this source file in an html page via\n *   {@code <script type=\"text/javascript\" src=\"/path/to/prettify.js\"></script>}\n * <li> define style rules.  See the example page for examples.\n * <li> mark the {@code <pre>} and {@code <code>&#125; tags in your source with\n *    &#123;@code class=prettyprint.&#125;\n *    You can also use the (html deprecated) &#123;@code <xmp>&#125; tag, but the pretty\n *    printer needs to do more substantial DOM manipulations to support that, so\n *    some css styles may not be preserved.\n * </ol>\n * That's it.  I wanted to keep the API as simple as possible, so there's no\n * need to specify which language the code is in, but if you wish, you can add\n * another class to the &#123;@code <pre>&#125; or &#123;@code <code>&#125; element to specify the\n * language, as in &#123;@code <pre class=\"prettyprint lang-java\">&#125;.  Any class that\n * starts with \"lang-\" followed by a file extension, specifies the file type.\n * See the \"lang-*.js\" files in this directory for code that implements\n * per-language file handlers.\n * <p>\n * Change log:<br>\n * cbeust, 2006/08/22\n * <blockquote>\n *   Java annotations (start with \"@\") are now captured as literals (\"lit\")\n * </blockquote>\n * @requires console\n */\n\n// JSLint declarations\n/*global console, document, navigator, setTimeout, window, define */\n\n/**\n * @typedef &#123;!Array.<number|string>&#125;\n * Alternating indices and the decorations that should be inserted there.\n * The indices are monotonically increasing.\n */\nvar DecorationsT;\n\n/**\n * @typedef &#123;!&#123;\n *   sourceNode: !Element,\n *   pre: !(number|boolean),\n *   langExtension: ?string,\n *   numberLines: ?(number|boolean),\n *   sourceCode: ?string,\n *   spans: ?(Array.<number|Node>),\n *   basePos: ?number,\n *   decorations: ?DecorationsT\n * &#125;&#125;\n * <dl>\n *  <dt>sourceNode<dd>the element containing the source\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>pre<dd>truthy if white-space in text nodes\n *     should be considered significant.\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. &#123;@code <BR>&#125;) corresponding to that\n *     span.\n *  <dt>decorations<dd>an array of style classes preceded\n *     by the position at which they start in job.sourceCode in order\n *  <dt>basePos<dd>integer position of this.sourceCode in the larger chunk of\n *     source.\n * </dl>\n */\nvar JobT;\n\n/**\n * @typedef &#123;!&#123;\n *   sourceCode: string,\n *   spans: !(Array.<number|Node>)\n * &#125;&#125;\n * <dl>\n *  <dt>sourceCode<dd>source as plain text\n *  <dt>spans<dd> alternating span start indices into source\n *     and the text node or element (e.g. &#123;@code <BR>&#125;) corresponding to that\n *     span.\n * </dl>\n */\nvar SourceSpansT;\n\n/** @define &#123;boolean&#125; */\nvar IN_GLOBAL_SCOPE = true;\n\n\n/**\n * &#123;@type !&#123;\n *   'createSimpleLexer': function (Array, Array): (function (JobT)),\n *   'registerLangHandler': function (function (JobT), Array.<string>),\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_NAME': string,\n *   'PR_ATTRIB_VALUE': string,\n *   'PR_COMMENT': string,\n *   'PR_DECLARATION': string,\n *   'PR_KEYWORD': string,\n *   'PR_LITERAL': string,\n *   'PR_NOCODE': string,\n *   'PR_PLAIN': string,\n *   'PR_PUNCTUATION': string,\n *   'PR_SOURCE': string,\n *   'PR_STRING': string,\n *   'PR_TAG': string,\n *   'PR_TYPE': string,\n *   'prettyPrintOne': function (string, string, number|boolean),\n *   'prettyPrint': function (?function, ?(HTMLElement|HTMLDocument))\n * &#125;&#125;\n * @const\n */\nvar PR;\n\n/**\n * Split &#123;@code prettyPrint&#125; into multiple timeouts so as not to interfere with\n * UI events.\n * If set to &#123;@code false&#125;, &#123;@code prettyPrint()&#125; is synchronous.\n */\nvar PR_SHOULD_USE_CONTINUATION = true\nif (typeof window !== 'undefined') &#123;\n  window['PR_SHOULD_USE_CONTINUATION'] = PR_SHOULD_USE_CONTINUATION;\n&#125;\n\n/**\n * Pretty print a chunk of code.\n * @param &#123;string&#125; sourceCodeHtml The HTML to pretty print.\n * @param &#123;string&#125; opt_langExtension The language name to use.\n *     Typically, a filename extension like 'cpp' or 'java'.\n * @param &#123;number|boolean&#125; opt_numberLines True to number lines,\n *     or the 1-indexed number of the first line in sourceCodeHtml.\n * @return &#123;string&#125; code as html, but prettier\n */\nvar prettyPrintOne;\n/**\n * Find all the &#123;@code <pre>&#125; and &#123;@code <code>&#125; tags in the DOM with\n * &#123;@code class=prettyprint&#125; and prettify them.\n *\n * @param &#123;Function&#125; opt_whenDone called when prettifying is done.\n * @param &#123;HTMLElement|HTMLDocument&#125; opt_root an element or document\n *   containing all the elements to pretty print.\n *   Defaults to &#123;@code document.body&#125;.\n */\nvar prettyPrint;\n\n\n(function () &#123;\n  var win = (typeof window !== 'undefined') ? window : &#123;&#125;;\n  // Keyword lists for various languages.\n  // We use things that coerce to strings to make them compact when minified\n  // and to defeat aggressive optimizers that fold large string constants.\n  var FLOW_CONTROL_KEYWORDS = [\"break,continue,do,else,for,if,return,while\"];\n  var C_KEYWORDS = [FLOW_CONTROL_KEYWORDS,\"auto,case,char,const,default,\" +\n      \"double,enum,extern,float,goto,inline,int,long,register,restrict,short,signed,\" +\n      \"sizeof,static,struct,switch,typedef,union,unsigned,void,volatile\"];\n  var COMMON_KEYWORDS = [C_KEYWORDS,\"catch,class,delete,false,import,\" +\n      \"new,operator,private,protected,public,this,throw,true,try,typeof\"];\n  var CPP_KEYWORDS = [COMMON_KEYWORDS,\"alignas,alignof,align_union,asm,axiom,bool,\" +\n      \"concept,concept_map,const_cast,constexpr,decltype,delegate,\" +\n      \"dynamic_cast,explicit,export,friend,generic,late_check,\" +\n      \"mutable,namespace,noexcept,noreturn,nullptr,property,reinterpret_cast,static_assert,\" +\n      \"static_cast,template,typeid,typename,using,virtual,where\"];\n  var JAVA_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,assert,boolean,byte,extends,finally,final,implements,import,\" +\n      \"instanceof,interface,null,native,package,strictfp,super,synchronized,\" +\n      \"throws,transient\"];\n  var CSHARP_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,add,alias,as,ascending,async,await,base,bool,by,byte,checked,decimal,delegate,descending,\" +\n      \"dynamic,event,finally,fixed,foreach,from,get,global,group,implicit,in,interface,\" +\n      \"internal,into,is,join,let,lock,null,object,out,override,orderby,params,\" +\n      \"partial,readonly,ref,remove,sbyte,sealed,select,set,stackalloc,string,select,uint,ulong,\" +\n      \"unchecked,unsafe,ushort,value,var,virtual,where,yield\"];\n  var COFFEE_KEYWORDS = \"all,and,by,catch,class,else,extends,false,finally,\" +\n      \"for,if,in,is,isnt,loop,new,no,not,null,of,off,on,or,return,super,then,\" +\n      \"throw,true,try,unless,until,when,while,yes\";\n  var JSCRIPT_KEYWORDS = [COMMON_KEYWORDS,\n      \"abstract,async,await,constructor,debugger,enum,eval,export,from,function,\" +\n      \"get,import,implements,instanceof,interface,let,null,of,set,undefined,\" +\n      \"var,with,yield,Infinity,NaN\"];\n  var PERL_KEYWORDS = \"caller,delete,die,do,dump,elsif,eval,exit,foreach,for,\" +\n      \"goto,if,import,last,local,my,next,no,our,print,package,redo,require,\" +\n      \"sub,undef,unless,until,use,wantarray,while,BEGIN,END\";\n  var PYTHON_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"and,as,assert,class,def,del,\" +\n      \"elif,except,exec,finally,from,global,import,in,is,lambda,\" +\n      \"nonlocal,not,or,pass,print,raise,try,with,yield,\" +\n      \"False,True,None\"];\n  var RUBY_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"alias,and,begin,case,class,\" +\n      \"def,defined,elsif,end,ensure,false,in,module,next,nil,not,or,redo,\" +\n      \"rescue,retry,self,super,then,true,undef,unless,until,when,yield,\" +\n      \"BEGIN,END\"];\n  var SH_KEYWORDS = [FLOW_CONTROL_KEYWORDS, \"case,done,elif,esac,eval,fi,\" +\n      \"function,in,local,set,then,until\"];\n  var ALL_KEYWORDS = [\n      CPP_KEYWORDS, CSHARP_KEYWORDS, JAVA_KEYWORDS, JSCRIPT_KEYWORDS,\n      PERL_KEYWORDS, PYTHON_KEYWORDS, RUBY_KEYWORDS, SH_KEYWORDS];\n  var C_TYPES = /^(DIR|FILE|array|vector|(de|priority_)?queue|(forward_)?list|stack|(const_)?(reverse_)?iterator|(unordered_)?(multi)?(set|map)|bitset|u?(int|float)\\d*)\\b/;\n\n  // token style names.  correspond to css classes\n  /**\n   * token style for a string literal\n   * @const\n   */\n  var PR_STRING = 'str';\n  /**\n   * token style for a keyword\n   * @const\n   */\n  var PR_KEYWORD = 'kwd';\n  /**\n   * token style for a comment\n   * @const\n   */\n  var PR_COMMENT = 'com';\n  /**\n   * token style for a type\n   * @const\n   */\n  var PR_TYPE = 'typ';\n  /**\n   * token style for a literal value.  e.g. 1, null, true.\n   * @const\n   */\n  var PR_LITERAL = 'lit';\n  /**\n   * token style for a punctuation string.\n   * @const\n   */\n  var PR_PUNCTUATION = 'pun';\n  /**\n   * token style for plain text.\n   * @const\n   */\n  var PR_PLAIN = 'pln';\n\n  /**\n   * token style for an sgml tag.\n   * @const\n   */\n  var PR_TAG = 'tag';\n  /**\n   * token style for a markup declaration such as a DOCTYPE.\n   * @const\n   */\n  var PR_DECLARATION = 'dec';\n  /**\n   * token style for embedded source.\n   * @const\n   */\n  var PR_SOURCE = 'src';\n  /**\n   * token style for an sgml attribute name.\n   * @const\n   */\n  var PR_ATTRIB_NAME = 'atn';\n  /**\n   * token style for an sgml attribute value.\n   * @const\n   */\n  var PR_ATTRIB_VALUE = 'atv';\n\n  /**\n   * A class that indicates a section of markup that is not code, e.g. to allow\n   * embedding of line numbers within code listings.\n   * @const\n   */\n  var PR_NOCODE = 'nocode';\n\n\n  // Regex pattern below is automatically generated by regexpPrecederPatterns.pl\n  // Do not modify, your changes will be erased.\n\n  // CAVEAT: this does not properly handle the case where a regular\n  // expression immediately follows another since a regular expression may\n  // have flags for case-sensitivity and the like.  Having regexp tokens\n  // adjacent is not valid in any language I'm aware of, so I'm punting.\n  // TODO: maybe style special characters inside a regexp as punctuation.\n\n  /**\n   * A set of tokens that can precede a regular expression literal in\n   * javascript\n   * http://web.archive.org/web/20070717142515/http://www.mozilla.org/js/language/js20/rationale/syntax.html\n   * has the full list, but I've removed ones that might be problematic when\n   * seen in languages that don't support regular expression literals.\n   *\n   * Specifically, I've removed any keywords that can't precede a regexp\n   * literal in a syntactically legal javascript program, and I've removed the\n   * \"in\" keyword since it's not a keyword in many languages, and might be used\n   * as a count of inches.\n   *\n   * The link above does not accurately describe EcmaScript rules since\n   * it fails to distinguish between (a=++/b/i) and (a++/b/i) but it works\n   * very well in practice.\n   *\n   * @private\n   * @const\n   */\n  var REGEXP_PRECEDER_PATTERN = '(?:^^\\\\.?|[+-]|[!=]=?=?|\\\\#|%=?|&&?=?|\\\\(|\\\\*=?|[+\\\\-]=|->|\\\\/=?|::?|<<?=?|>>?>?=?|,|;|\\\\?|@|\\\\[|~|&#123;|\\\\^\\\\^?=?|\\\\|\\\\|?=?|break|case|continue|delete|do|else|finally|instanceof|return|throw|try|typeof)\\\\s*';\n\n\n  /**\n   * Given a group of &#123;@link RegExp&#125;s, returns a &#123;@code RegExp&#125; that globally\n   * matches the union of the sets of strings matched by the input RegExp.\n   * Since it matches globally, if the input strings have a start-of-input\n   * anchor (/^.../), it is ignored for the purposes of unioning.\n   * @param &#123;Array.<RegExp>&#125; regexs non multiline, non-global regexs.\n   * @return &#123;RegExp&#125; a global regex.\n   */\n  function combinePrefixPatterns(regexs) &#123;\n    var capturedGroupIndex = 0;\n\n    var needToFoldCase = false;\n    var ignoreCase = false;\n    for (var i = 0, n = regexs.length; i < n; ++i) &#123;\n      var regex = regexs[i];\n      if (regex.ignoreCase) &#123;\n        ignoreCase = true;\n      &#125; else if (/[a-z]/i.test(regex.source.replace(\n                     /\\\\u[0-9a-f]&#123;4&#125;|\\\\x[0-9a-f]&#123;2&#125;|\\\\[^ux]/gi, ''))) &#123;\n        needToFoldCase = true;\n        ignoreCase = false;\n        break;\n      &#125;\n    &#125;\n\n    var escapeCharToCodeUnit = &#123;\n      'b': 8,\n      't': 9,\n      'n': 0xa,\n      'v': 0xb,\n      'f': 0xc,\n      'r': 0xd\n    &#125;;\n\n    function decodeEscape(charsetPart) &#123;\n      var cc0 = charsetPart.charCodeAt(0);\n      if (cc0 !== 92 /* \\\\ */) &#123;\n        return cc0;\n      &#125;\n      var c1 = charsetPart.charAt(1);\n      cc0 = escapeCharToCodeUnit[c1];\n      if (cc0) &#123;\n        return cc0;\n      &#125; else if ('0' <= c1 && c1 <= '7') &#123;\n        return parseInt(charsetPart.substring(1), 8);\n      &#125; else if (c1 === 'u' || c1 === 'x') &#123;\n        return parseInt(charsetPart.substring(2), 16);\n      &#125; else &#123;\n        return charsetPart.charCodeAt(1);\n      &#125;\n    &#125;\n\n    function encodeEscape(charCode) &#123;\n      if (charCode < 0x20) &#123;\n        return (charCode < 0x10 ? '\\\\x0' : '\\\\x') + charCode.toString(16);\n      &#125;\n      var ch = String.fromCharCode(charCode);\n      return (ch === '\\\\' || ch === '-' || ch === ']' || ch === '^')\n          ? \"\\\\\" + ch : ch;\n    &#125;\n\n    function caseFoldCharset(charSet) &#123;\n      var charsetParts = charSet.substring(1, charSet.length - 1).match(\n          new RegExp(\n              '\\\\\\\\u[0-9A-Fa-f]&#123;4&#125;'\n              + '|\\\\\\\\x[0-9A-Fa-f]&#123;2&#125;'\n              + '|\\\\\\\\[0-3][0-7]&#123;0,2&#125;'\n              + '|\\\\\\\\[0-7]&#123;1,2&#125;'\n              + '|\\\\\\\\[\\\\s\\\\S]'\n              + '|-'\n              + '|[^-\\\\\\\\]',\n              'g'));\n      var ranges = [];\n      var inverse = charsetParts[0] === '^';\n\n      var out = ['['];\n      if (inverse) &#123; out.push('^'); &#125;\n\n      for (var i = inverse ? 1 : 0, n = charsetParts.length; i < n; ++i) &#123;\n        var p = charsetParts[i];\n        if (/\\\\[bdsw]/i.test(p)) &#123;  // Don't muck with named groups.\n          out.push(p);\n        &#125; else &#123;\n          var start = decodeEscape(p);\n          var end;\n          if (i + 2 < n && '-' === charsetParts[i + 1]) &#123;\n            end = decodeEscape(charsetParts[i + 2]);\n            i += 2;\n          &#125; else &#123;\n            end = start;\n          &#125;\n          ranges.push([start, end]);\n          // If the range might intersect letters, then expand it.\n          // This case handling is too simplistic.\n          // It does not deal with non-latin case folding.\n          // It works for latin source code identifiers though.\n          if (!(end < 65 || start > 122)) &#123;\n            if (!(end < 65 || start > 90)) &#123;\n              ranges.push([Math.max(65, start) | 32, Math.min(end, 90) | 32]);\n            &#125;\n            if (!(end < 97 || start > 122)) &#123;\n              ranges.push([Math.max(97, start) & ~32, Math.min(end, 122) & ~32]);\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n\n      // [[1, 10], [3, 4], [8, 12], [14, 14], [16, 16], [17, 17]]\n      // -> [[1, 12], [14, 14], [16, 17]]\n      ranges.sort(function (a, b) &#123; return (a[0] - b[0]) || (b[1]  - a[1]); &#125;);\n      var consolidatedRanges = [];\n      var lastRange = [];\n      for (var i = 0; i < ranges.length; ++i) &#123;\n        var range = ranges[i];\n        if (range[0] <= lastRange[1] + 1) &#123;\n          lastRange[1] = Math.max(lastRange[1], range[1]);\n        &#125; else &#123;\n          consolidatedRanges.push(lastRange = range);\n        &#125;\n      &#125;\n\n      for (var i = 0; i < consolidatedRanges.length; ++i) &#123;\n        var range = consolidatedRanges[i];\n        out.push(encodeEscape(range[0]));\n        if (range[1] > range[0]) &#123;\n          if (range[1] + 1 > range[0]) &#123; out.push('-'); &#125;\n          out.push(encodeEscape(range[1]));\n        &#125;\n      &#125;\n      out.push(']');\n      return out.join('');\n    &#125;\n\n    function allowAnywhereFoldCaseAndRenumberGroups(regex) &#123;\n      // Split into character sets, escape sequences, punctuation strings\n      // like ('(', '(?:', ')', '^'), and runs of characters that do not\n      // include any of the above.\n      var parts = regex.source.match(\n          new RegExp(\n              '(?:'\n              + '\\\\[(?:[^\\\\x5C\\\\x5D]|\\\\\\\\[\\\\s\\\\S])*\\\\]'  // a character set\n              + '|\\\\\\\\u[A-Fa-f0-9]&#123;4&#125;'  // a unicode escape\n              + '|\\\\\\\\x[A-Fa-f0-9]&#123;2&#125;'  // a hex escape\n              + '|\\\\\\\\[0-9]+'  // a back-reference or octal escape\n              + '|\\\\\\\\[^ux0-9]'  // other escape sequence\n              + '|\\\\(\\\\?[:!=]'  // start of a non-capturing group\n              + '|[\\\\(\\\\)\\\\^]'  // start/end of a group, or line start\n              + '|[^\\\\x5B\\\\x5C\\\\(\\\\)\\\\^]+'  // run of other characters\n              + ')',\n              'g'));\n      var n = parts.length;\n\n      // Maps captured group numbers to the number they will occupy in\n      // the output or to -1 if that has not been determined, or to\n      // undefined if they need not be capturing in the output.\n      var capturedGroups = [];\n\n      // Walk over and identify back references to build the capturedGroups\n      // mapping.\n      for (var i = 0, groupIndex = 0; i < n; ++i) &#123;\n        var p = parts[i];\n        if (p === '(') &#123;\n          // groups are 1-indexed, so max group index is count of '('\n          ++groupIndex;\n        &#125; else if ('\\\\' === p.charAt(0)) &#123;\n          var decimalValue = +p.substring(1);\n          if (decimalValue) &#123;\n            if (decimalValue <= groupIndex) &#123;\n              capturedGroups[decimalValue] = -1;\n            &#125; else &#123;\n              // Replace with an unambiguous escape sequence so that\n              // an octal escape sequence does not turn into a backreference\n              // to a capturing group from an earlier regex.\n              parts[i] = encodeEscape(decimalValue);\n            &#125;\n          &#125;\n        &#125;\n      &#125;\n\n      // Renumber groups and reduce capturing groups to non-capturing groups\n      // where possible.\n      for (var i = 1; i < capturedGroups.length; ++i) &#123;\n        if (-1 === capturedGroups[i]) &#123;\n          capturedGroups[i] = ++capturedGroupIndex;\n        &#125;\n      &#125;\n      for (var i = 0, groupIndex = 0; i < n; ++i) &#123;\n        var p = parts[i];\n        if (p === '(') &#123;\n          ++groupIndex;\n          if (!capturedGroups[groupIndex]) &#123;\n            parts[i] = '(?:';\n          &#125;\n        &#125; else if ('\\\\' === p.charAt(0)) &#123;\n          var decimalValue = +p.substring(1);\n          if (decimalValue && decimalValue <= groupIndex) &#123;\n            parts[i] = '\\\\' + capturedGroups[decimalValue];\n          &#125;\n        &#125;\n      &#125;\n\n      // Remove any prefix anchors so that the output will match anywhere.\n      // ^^ really does mean an anchored match though.\n      for (var i = 0; i < n; ++i) &#123;\n        if ('^' === parts[i] && '^' !== parts[i + 1]) &#123; parts[i] = ''; &#125;\n      &#125;\n\n      // Expand letters to groups to handle mixing of case-sensitive and\n      // case-insensitive patterns if necessary.\n      if (regex.ignoreCase && needToFoldCase) &#123;\n        for (var i = 0; i < n; ++i) &#123;\n          var p = parts[i];\n          var ch0 = p.charAt(0);\n          if (p.length >= 2 && ch0 === '[') &#123;\n            parts[i] = caseFoldCharset(p);\n          &#125; else if (ch0 !== '\\\\') &#123;\n            // TODO: handle letters in numeric escapes.\n            parts[i] = p.replace(\n                /[a-zA-Z]/g,\n                function (ch) &#123;\n                  var cc = ch.charCodeAt(0);\n                  return '[' + String.fromCharCode(cc & ~32, cc | 32) + ']';\n                &#125;);\n          &#125;\n        &#125;\n      &#125;\n\n      return parts.join('');\n    &#125;\n\n    var rewritten = [];\n    for (var i = 0, n = regexs.length; i < n; ++i) &#123;\n      var regex = regexs[i];\n      if (regex.global || regex.multiline) &#123; throw new Error('' + regex); &#125;\n      rewritten.push(\n          '(?:' + allowAnywhereFoldCaseAndRenumberGroups(regex) + ')');\n    &#125;\n\n    return new RegExp(rewritten.join('|'), ignoreCase ? 'gi' : 'g');\n  &#125;\n\n\n  /**\n   * Split markup into a string of source code and an array mapping ranges in\n   * that string to the text nodes in which they appear.\n   *\n   * <p>\n   * The HTML DOM structure:</p>\n   * <pre>\n   * (Element   \"p\"\n   *   (Element \"b\"\n   *     (Text  \"print \"))       ; #1\n   *   (Text    \"'Hello '\")      ; #2\n   *   (Element \"br\")            ; #3\n   *   (Text    \"  + 'World';\")) ; #4\n   * </pre>\n   * <p>\n   * corresponds to the HTML\n   * &#123;@code <p><b>print </b>'Hello '<br>  + 'World';</p>&#125;.</p>\n   *\n   * <p>\n   * It will produce the output:</p>\n   * <pre>\n   * &#123;\n   *   sourceCode: \"print 'Hello '\\n  + 'World';\",\n   *   //                     1          2\n   *   //           012345678901234 5678901234567\n   *   spans: [0, #1, 6, #2, 14, #3, 15, #4]\n   * &#125;\n   * </pre>\n   * <p>\n   * where #1 is a reference to the &#123;@code \"print \"&#125; text node above, and so\n   * on for the other text nodes.\n   * </p>\n   *\n   * <p>\n   * The &#123;@code&#125; spans array is an array of pairs.  Even elements are the start\n   * indices of substrings, and odd elements are the text nodes (or BR elements)\n   * that contain the text for those substrings.\n   * Substrings continue until the next index or the end of the source.\n   * </p>\n   *\n   * @param &#123;Node&#125; node an HTML DOM subtree containing source-code.\n   * @param &#123;boolean|number&#125; isPreformatted truthy if white-space in\n   *    text nodes should be considered significant.\n   * @return &#123;SourceSpansT&#125; source code and the nodes in which they occur.\n   */\n  function extractSourceSpans(node, isPreformatted) &#123;\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n\n    var chunks = [];\n    var length = 0;\n    var spans = [];\n    var k = 0;\n\n    function walk(node) &#123;\n      var type = node.nodeType;\n      if (type == 1) &#123;  // Element\n        if (nocode.test(node.className)) &#123; return; &#125;\n        for (var child = node.firstChild; child; child = child.nextSibling) &#123;\n          walk(child);\n        &#125;\n        var nodeName = node.nodeName.toLowerCase();\n        if ('br' === nodeName || 'li' === nodeName) &#123;\n          chunks[k] = '\\n';\n          spans[k << 1] = length++;\n          spans[(k++ << 1) | 1] = node;\n        &#125;\n      &#125; else if (type == 3 || type == 4) &#123;  // Text\n        var text = node.nodeValue;\n        if (text.length) &#123;\n          if (!isPreformatted) &#123;\n            text = text.replace(/[ \\t\\r\\n]+/g, ' ');\n          &#125; else &#123;\n            text = text.replace(/\\r\\n?/g, '\\n');  // Normalize newlines.\n          &#125;\n          // TODO: handle tabs here?\n          chunks[k] = text;\n          spans[k << 1] = length;\n          length += text.length;\n          spans[(k++ << 1) | 1] = node;\n        &#125;\n      &#125;\n    &#125;\n\n    walk(node);\n\n    return &#123;\n      sourceCode: chunks.join('').replace(/\\n$/, ''),\n      spans: spans\n    &#125;;\n  &#125;\n\n\n  /**\n   * Apply the given language handler to sourceCode and add the resulting\n   * decorations to out.\n   * @param &#123;!Element&#125; sourceNode\n   * @param &#123;number&#125; basePos the index of sourceCode within the chunk of source\n   *    whose decorations are already present on out.\n   * @param &#123;string&#125; sourceCode\n   * @param &#123;function(JobT)&#125; langHandler\n   * @param &#123;DecorationsT&#125; out\n   */\n  function appendDecorations(\n      sourceNode, basePos, sourceCode, langHandler, out) &#123;\n    if (!sourceCode) &#123; return; &#125;\n    /** @type &#123;JobT&#125; */\n    var job = &#123;\n      sourceNode: sourceNode,\n      pre: 1,\n      langExtension: null,\n      numberLines: null,\n      sourceCode: sourceCode,\n      spans: null,\n      basePos: basePos,\n      decorations: null\n    &#125;;\n    langHandler(job);\n    out.push.apply(out, job.decorations);\n  &#125;\n\n  var notWs = /\\S/;\n\n  /**\n   * Given an element, if it contains only one child element and any text nodes\n   * it contains contain only space characters, return the sole child element.\n   * Otherwise returns undefined.\n   * <p>\n   * This is meant to return the CODE element in &#123;@code <pre><code ...>&#125; when\n   * there is a single child element that contains all the non-space textual\n   * content, but not to return anything where there are multiple child elements\n   * as in &#123;@code <pre><code>...</code><code>...</code></pre>} or when there\n   * is textual content.\n   */\n  function childContentWrapper(element) {\n    var wrapper = undefined;\n    for (var c = element.firstChild; c; c = c.nextSibling) {\n      var type = c.nodeType;\n      wrapper = (type === 1)  // Element Node\n          ? (wrapper ? element : c)\n          : (type === 3)  // Text Node\n          ? (notWs.test(c.nodeValue) ? element : wrapper)\n          : wrapper;\n    }\n    return wrapper === element ? undefined : wrapper;\n  }\n\n  /** Given triples of [style, pattern, context] returns a lexing function,\n    * The lexing function interprets the patterns to find token boundaries and\n    * returns a decoration list of the form\n    * [index_0, style_0, index_1, style_1, ..., index_n, style_n]\n    * where index_n is an index into the sourceCode, and style_n is a style\n    * constant like PR_PLAIN.  index_n-1 <= index_n, and style_n-1 applies to\n    * all characters in sourceCode[index_n-1:index_n].\n    *\n    * The stylePatterns is a list whose elements have the form\n    * [style : string, pattern : RegExp, DEPRECATED, shortcut : string].\n    *\n    * Style is a style constant like PR_PLAIN, or can be a string of the\n    * form 'lang-FOO', where FOO is a language extension describing the\n    * language of the portion of the token in $1 after pattern executes.\n    * E.g., if style is 'lang-lisp', and group 1 contains the text\n    * '(hello (world))', then that portion of the token will be passed to the\n    * registered lisp handler for formatting.\n    * The text before and after group 1 will be restyled using this decorator\n    * so decorators should take care that this doesn't result in infinite\n    * recursion.  For example, the HTML lexer rule for SCRIPT elements looks\n    * something like ['lang-js', /<[s]cript>(.+?)<\\/script>/].  This may match\n    * '<script>foo()<\\/script>', which would cause the current decorator to\n    * be called with '<script>' which would not match the same rule since\n    * group 1 must not be empty, so it would be instead styled as PR_TAG by\n    * the generic tag rule.  The handler registered for the 'js' extension would\n    * then be called with 'foo()', and finally, the current decorator would\n    * be called with '<\\/script>' which would not match the original rule and\n    * so the generic tag rule would identify it as a tag.\n    *\n    * Pattern must only match prefixes, and if it matches a prefix, then that\n    * match is considered a token with the same style.\n    *\n    * Context is applied to the last non-whitespace, non-comment token\n    * recognized.\n    *\n    * Shortcut is an optional string of characters, any of which, if the first\n    * character, gurantee that this pattern and only this pattern matches.\n    *\n    * @param {Array} shortcutStylePatterns patterns that always start with\n    *   a known character.  Must have a shortcut string.\n    * @param {Array} fallthroughStylePatterns patterns that will be tried in\n    *   order if the shortcut ones fail.  May have shortcuts.\n    *\n    * @return {function (JobT)} a function that takes an undecorated job and\n    *   attaches a list of decorations.\n    */\n  function createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns) {\n    var shortcuts = {};\n    var tokenizer;\n    (function () {\n      var allPatterns = shortcutStylePatterns.concat(fallthroughStylePatterns);\n      var allRegexs = [];\n      var regexKeys = {};\n      for (var i = 0, n = allPatterns.length; i < n; ++i) {\n        var patternParts = allPatterns[i];\n        var shortcutChars = patternParts[3];\n        if (shortcutChars) {\n          for (var c = shortcutChars.length; --c >= 0;) {\n            shortcuts[shortcutChars.charAt(c)] = patternParts;\n          }\n        }\n        var regex = patternParts[1];\n        var k = '' + regex;\n        if (!regexKeys.hasOwnProperty(k)) {\n          allRegexs.push(regex);\n          regexKeys[k] = null;\n        }\n      }\n      allRegexs.push(/[\\0-\\uffff]/);\n      tokenizer = combinePrefixPatterns(allRegexs);\n    })();\n\n    var nPatterns = fallthroughStylePatterns.length;\n\n    /**\n     * Lexes job.sourceCode and attaches an output array job.decorations of\n     * style classes preceded by the position at which they start in\n     * job.sourceCode in order.\n     *\n     * @type{function (JobT)}\n     */\n    var decorate = function (job) {\n      var sourceCode = job.sourceCode, basePos = job.basePos;\n      var sourceNode = job.sourceNode;\n      /** Even entries are positions in source in ascending order.  Odd enties\n        * are style markers (e.g., PR_COMMENT) that run from that position until\n        * the end.\n        * @type {DecorationsT}\n        */\n      var decorations = [basePos, PR_PLAIN];\n      var pos = 0;  // index into sourceCode\n      var tokens = sourceCode.match(tokenizer) || [];\n      var styleCache = {};\n\n      for (var ti = 0, nTokens = tokens.length; ti < nTokens; ++ti) {\n        var token = tokens[ti];\n        var style = styleCache[token];\n        var match = void 0;\n\n        var isEmbedded;\n        if (typeof style === 'string') {\n          isEmbedded = false;\n        } else {\n          var patternParts = shortcuts[token.charAt(0)];\n          if (patternParts) {\n            match = token.match(patternParts[1]);\n            style = patternParts[0];\n          } else {\n            for (var i = 0; i < nPatterns; ++i) {\n              patternParts = fallthroughStylePatterns[i];\n              match = token.match(patternParts[1]);\n              if (match) {\n                style = patternParts[0];\n                break;\n              }\n            }\n\n            if (!match) {  // make sure that we make progress\n              style = PR_PLAIN;\n            }\n          }\n\n          isEmbedded = style.length >= 5 && 'lang-' === style.substring(0, 5);\n          if (isEmbedded && !(match && typeof match[1] === 'string')) {\n            isEmbedded = false;\n            style = PR_SOURCE;\n          }\n\n          if (!isEmbedded) { styleCache[token] = style; }\n        }\n\n        var tokenStart = pos;\n        pos += token.length;\n\n        if (!isEmbedded) {\n          decorations.push(basePos + tokenStart, style);\n        } else {  // Treat group 1 as an embedded block of source code.\n          var embeddedSource = match[1];\n          var embeddedSourceStart = token.indexOf(embeddedSource);\n          var embeddedSourceEnd = embeddedSourceStart + embeddedSource.length;\n          if (match[2]) {\n            // If embeddedSource can be blank, then it would match at the\n            // beginning which would cause us to infinitely recurse on the\n            // entire token, so we catch the right context in match[2].\n            embeddedSourceEnd = token.length - match[2].length;\n            embeddedSourceStart = embeddedSourceEnd - embeddedSource.length;\n          }\n          var lang = style.substring(5);\n          // Decorate the left of the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart,\n              token.substring(0, embeddedSourceStart),\n              decorate, decorations);\n          // Decorate the embedded source\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceStart,\n              embeddedSource,\n              langHandlerForExtension(lang, embeddedSource),\n              decorations);\n          // Decorate the right of the embedded section\n          appendDecorations(\n              sourceNode,\n              basePos + tokenStart + embeddedSourceEnd,\n              token.substring(embeddedSourceEnd),\n              decorate, decorations);\n        }\n      }\n      job.decorations = decorations;\n    };\n    return decorate;\n  }\n\n  /** returns a function that produces a list of decorations from source text.\n    *\n    * This code treats \", ', and ` as string delimiters, and \\ as a string\n    * escape.  It does not recognize perl's qq() style strings.\n    * It has no special handling for double delimiter escapes as in basic, or\n    * the tripled delimiters used in python, but should work on those regardless\n    * although in those cases a single string literal may be broken up into\n    * multiple adjacent string literals.\n    *\n    * It recognizes C, C++, and shell style comments.\n    *\n    * @param {Object} options a set of optional parameters.\n    * @return {function (JobT)} a function that examines the source code\n    *     in the input job and builds a decoration list which it attaches to\n    *     the job.\n    */\n  function sourceDecorator(options) {\n    var shortcutStylePatterns = [], fallthroughStylePatterns = [];\n    if (options['tripleQuotedStrings']) {\n      // '''multi-line-string''', 'single-line-string', and double-quoted\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'\\'\\'(?:[^\\'\\\\]|\\\\[\\s\\S]|\\'{1,2}(?=[^\\']))*(?:\\'\\'\\'|$)|\\\"\\\"\\\"(?:[^\\\"\\\\]|\\\\[\\s\\S]|\\\"{1,2}(?=[^\\\"]))*(?:\\\"\\\"\\\"|$)|\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$))/,\n           null, '\\'\"']);\n    } else if (options['multiLineStrings']) {\n      // 'multi-line-string', \"multi-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,  /^(?:\\'(?:[^\\\\\\']|\\\\[\\s\\S])*(?:\\'|$)|\\\"(?:[^\\\\\\\"]|\\\\[\\s\\S])*(?:\\\"|$)|\\`(?:[^\\\\\\`]|\\\\[\\s\\S])*(?:\\`|$))/,\n           null, '\\'\"`']);\n    } else {\n      // 'single-line-string', \"single-line-string\"\n      shortcutStylePatterns.push(\n          [PR_STRING,\n           /^(?:\\'(?:[^\\\\\\'\\r\\n]|\\\\.)*(?:\\'|$)|\\\"(?:[^\\\\\\\"\\r\\n]|\\\\.)*(?:\\\"|$))/,\n           null, '\"\\'']);\n    }\n    if (options['verbatimStrings']) {\n      // verbatim-string-literal production from the C# grammar.  See issue 93.\n      fallthroughStylePatterns.push(\n          [PR_STRING, /^@\\\"(?:[^\\\"]|\\\"\\\")*(?:\\\"|$)/, null]);\n    }\n    var hc = options['hashComments'];\n    if (hc) {\n      if (options['cStyleComments']) {\n        if (hc > 1) {  // multiline hash comments\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:##(?:[^#]|#(?!##))*(?:###|$)|.*)/, null, '#']);\n        } else {\n          // Stop C preprocessor declarations at an unclosed open comment\n          shortcutStylePatterns.push(\n              [PR_COMMENT, /^#(?:(?:define|e(?:l|nd)if|else|error|ifn?def|include|line|pragma|undef|warning)\\b|[^\\r\\n]*)/,\n               null, '#']);\n        }\n        // #include <stdio.h>\n        fallthroughStylePatterns.push(\n            [PR_STRING,\n             /^<(?:(?:(?:\\.\\.\\/)*|\\/?)(?:[\\w-]+(?:\\/[\\w-]+)+)?[\\w-]+\\.h(?:h|pp|\\+\\+)?|[a-z]\\w*)>/,\n             null]);\n      } else {\n        shortcutStylePatterns.push([PR_COMMENT, /^#[^\\r\\n]*/, null, '#']);\n      }\n    }\n    if (options['cStyleComments']) {\n      fallthroughStylePatterns.push([PR_COMMENT, /^\\/\\/[^\\r\\n]*/, null]);\n      fallthroughStylePatterns.push(\n          [PR_COMMENT, /^\\/\\*[\\s\\S]*?(?:\\*\\/|$)/, null]);\n    }\n    var regexLiterals = options['regexLiterals'];\n    if (regexLiterals) {\n      /**\n       * @const\n       */\n      var regexExcls = regexLiterals > 1\n        ? ''  // Multiline regex literals\n        : '\\n\\r';\n      /**\n       * @const\n       */\n      var regexAny = regexExcls ? '.' : '[\\\\S\\\\s]';\n      /**\n       * @const\n       */\n      var REGEX_LITERAL = (\n          // A regular expression literal starts with a slash that is\n          // not followed by * or / so that it is not confused with\n          // comments.\n          '/(?=[^/*' + regexExcls + '])'\n          // and then contains any number of raw characters,\n          + '(?:[^/\\\\x5B\\\\x5C' + regexExcls + ']'\n          // escape sequences (\\x5C),\n          +    '|\\\\x5C' + regexAny\n          // or non-nesting character sets (\\x5B\\x5D);\n          +    '|\\\\x5B(?:[^\\\\x5C\\\\x5D' + regexExcls + ']'\n          +             '|\\\\x5C' + regexAny + ')*(?:\\\\x5D|$))+'\n          // finally closed by a /.\n          + '/');\n      fallthroughStylePatterns.push(\n          ['lang-regex',\n           RegExp('^' + REGEXP_PRECEDER_PATTERN + '(' + REGEX_LITERAL + ')')\n           ]);\n    }\n\n    var types = options['types'];\n    if (types) {\n      fallthroughStylePatterns.push([PR_TYPE, types]);\n    }\n\n    var keywords = (\"\" + options['keywords']).replace(/^ | $/g, '');\n    if (keywords.length) {\n      fallthroughStylePatterns.push(\n          [PR_KEYWORD,\n           new RegExp('^(?:' + keywords.replace(/[\\s,]+/g, '|') + ')\\\\b'),\n           null]);\n    }\n\n    shortcutStylePatterns.push([PR_PLAIN,       /^\\s+/, null, ' \\r\\n\\t\\xA0']);\n\n    var punctuation =\n      // The Bash man page says\n\n      // A word is a sequence of characters considered as a single\n      // unit by GRUB. Words are separated by metacharacters,\n      // which are the following plus space, tab, and newline: { }\n      // | & $ ; < >\n      // ...\n\n      // A word beginning with # causes that word and all remaining\n      // characters on that line to be ignored.\n\n      // which means that only a '#' after /(?:^|[{}|&$;<>\\s])/ starts a\n      // comment but empirically\n      // $ echo \n      // $ echo \\$#\n      // $#\n      // $ echo }#\n      // }#\n\n      // so /(?:^|[|&;<>\\s])/ is more appropriate.\n\n      // http://gcc.gnu.org/onlinedocs/gcc-2.95.3/cpp_1.html#SEC3\n      // suggests that this definition is compatible with a\n      // default mode that tries to use a single token definition\n      // to recognize both bash/python style comments and C\n      // preprocessor directives.\n\n      // This definition of punctuation does not include # in the list of\n      // follow-on exclusions, so # will not be broken before if preceeded\n      // by a punctuation character.  We could try to exclude # after\n      // [|&;<>] but that doesn't seem to cause many major problems.\n      // If that does turn out to be a problem, we should change the below\n      // when hc is truthy to include # in the run of punctuation characters\n      // only when not followint [|&;<>].\n      '^.[^\\\\s\\\\w.$@\\'\"`/\\\\\\\\]*';\n    if (options['regexLiterals']) {\n      punctuation += '(?!\\s*\\/)';\n    }\n\n    fallthroughStylePatterns.push(\n        // TODO(mikesamuel): recognize non-latin letters and numerals in idents\n        [PR_LITERAL,     /^@[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_TYPE,        /^(?:[@_]?[A-Z]+[a-z][A-Za-z_$@0-9]*|\\w+_t\\b)/, null],\n        [PR_PLAIN,       /^[a-z_$][a-z_$@0-9]*/i, null],\n        [PR_LITERAL,\n         new RegExp(\n             '^(?:'\n             // A hex number\n             + '0x[a-f0-9]+'\n             // or an octal or decimal number,\n             + '|(?:\\\\d(?:_\\\\d+)*\\\\d*(?:\\\\.\\\\d*)?|\\\\.\\\\d\\\\+)'\n             // possibly in scientific notation\n             + '(?:e[+\\\\-]?\\\\d+)?'\n             + ')'\n             // with an optional modifier like UL for unsigned long\n             + '[a-z]*', 'i'),\n         null, '0123456789'],\n        // Don't treat escaped quotes in bash as starting strings.\n        // See issue 144.\n        [PR_PLAIN,       /^\\\\[\\s\\S]?/, null],\n        [PR_PUNCTUATION, new RegExp(punctuation), null]);\n\n    return createSimpleLexer(shortcutStylePatterns, fallthroughStylePatterns);\n  }\n\n  var decorateSource = sourceDecorator({\n        'keywords': ALL_KEYWORDS,\n        'hashComments': true,\n        'cStyleComments': true,\n        'multiLineStrings': true,\n        'regexLiterals': true\n      });\n\n  /**\n   * Given a DOM subtree, wraps it in a list, and puts each line into its own\n   * list item.\n   *\n   * @param {Node} node modified in place.  Its content is pulled into an\n   *     HTMLOListElement, and each line is moved into a separate list item.\n   *     This requires cloning elements, so the input might not have unique\n   *     IDs after numbering.\n   * @param {number|null|boolean} startLineNum\n   *     If truthy, coerced to an integer which is the 1-indexed line number\n   *     of the first line of code.  The number of the first line will be\n   *     attached to the list.\n   * @param {boolean} isPreformatted true iff white-space in text nodes should\n   *     be treated as significant.\n   */\n  function numberLines(node, startLineNum, isPreformatted) {\n    var nocode = /(?:^|\\s)nocode(?:\\s|$)/;\n    var lineBreak = /\\r\\n?|\\n/;\n\n    var document = node.ownerDocument;\n\n    var li = document.createElement('li');\n    while (node.firstChild) {\n      li.appendChild(node.firstChild);\n    }\n    // An array of lines.  We split below, so this is initialized to one\n    // un-split line.\n    var listItems = [li];\n\n    function walk(node) {\n      var type = node.nodeType;\n      if (type == 1 && !nocode.test(node.className)) {  // Element\n        if ('br' === node.nodeName.toLowerCase()) {\n          breakAfter(node);\n          // Discard the <BR> since it is now flush against a </LI>.\n          if (node.parentNode) {\n            node.parentNode.removeChild(node);\n          }\n        } else {\n          for (var child = node.firstChild; child; child = child.nextSibling) {\n            walk(child);\n          }\n        }\n      } else if ((type == 3 || type == 4) && isPreformatted) {  // Text\n        var text = node.nodeValue;\n        var match = text.match(lineBreak);\n        if (match) {\n          var firstLine = text.substring(0, match.index);\n          node.nodeValue = firstLine;\n          var tail = text.substring(match.index + match[0].length);\n          if (tail) {\n            var parent = node.parentNode;\n            parent.insertBefore(\n              document.createTextNode(tail), node.nextSibling);\n          }\n          breakAfter(node);\n          if (!firstLine) {\n            // Don't leave blank text nodes in the DOM.\n            node.parentNode.removeChild(node);\n          }\n        }\n      }\n    }\n\n    // Split a line after the given node.\n    function breakAfter(lineEndNode) {\n      // If there's nothing to the right, then we can skip ending the line\n      // here, and move root-wards since splitting just before an end-tag\n      // would require us to create a bunch of empty copies.\n      while (!lineEndNode.nextSibling) {\n        lineEndNode = lineEndNode.parentNode;\n        if (!lineEndNode) { return; }\n      }\n\n      function breakLeftOf(limit, copy) {\n        // Clone shallowly if this node needs to be on both sides of the break.\n        var rightSide = copy ? limit.cloneNode(false) : limit;\n        var parent = limit.parentNode;\n        if (parent) {\n          // We clone the parent chain.\n          // This helps us resurrect important styling elements that cross lines.\n          // E.g. in <i>Foo<br>Bar</i>\n          // should be rewritten to <li><i>Foo</i></li><li><i>Bar</i></li>.\n          var parentClone = breakLeftOf(parent, 1);\n          // Move the clone and everything to the right of the original\n          // onto the cloned parent.\n          var next = limit.nextSibling;\n          parentClone.appendChild(rightSide);\n          for (var sibling = next; sibling; sibling = next) {\n            next = sibling.nextSibling;\n            parentClone.appendChild(sibling);\n          }\n        }\n        return rightSide;\n      }\n\n      var copiedListItem = breakLeftOf(lineEndNode.nextSibling, 0);\n\n      // Walk the parent chain until we reach an unattached LI.\n      for (var parent;\n           // Check nodeType since IE invents document fragments.\n           (parent = copiedListItem.parentNode) && parent.nodeType === 1;) {\n        copiedListItem = parent;\n      }\n      // Put it on the list of lines for later processing.\n      listItems.push(copiedListItem);\n    }\n\n    // Split lines while there are lines left to split.\n    for (var i = 0;  // Number of lines that have been split so far.\n         i < listItems.length;  // length updated by breakAfter calls.\n         ++i) {\n      walk(listItems[i]);\n    }\n\n    // Make sure numeric indices show correctly.\n    if (startLineNum === (startLineNum|0)) {\n      listItems[0].setAttribute('value', startLineNum);\n    }\n\n    var ol = document.createElement('ol');\n    ol.className = 'linenums';\n    var offset = Math.max(0, ((startLineNum - 1 /* zero index */)) | 0) || 0;\n    for (var i = 0, n = listItems.length; i < n; ++i) {\n      li = listItems[i];\n      // Stick a class on the LIs so that stylesheets can\n      // color odd/even rows, or any other row pattern that\n      // is co-prime with 10.\n      li.className = 'L' + ((i + offset) % 10);\n      if (!li.firstChild) {\n        li.appendChild(document.createTextNode('\\xA0'));\n      }\n      ol.appendChild(li);\n    }\n\n    node.appendChild(ol);\n  }\n\n\n  /**\n   * Breaks {@code job.sourceCode} around style boundaries in\n   * {@code job.decorations} and modifies {@code job.sourceNode} in place.\n   * @param {JobT} job\n   * @private\n   */\n  function recombineTagsAndDecorations(job) {\n    var isIE8OrEarlier = /\\bMSIE\\s(\\d+)/.exec(navigator.userAgent);\n    isIE8OrEarlier = isIE8OrEarlier && +isIE8OrEarlier[1] <= 8;\n    var newlineRe = /\\n/g;\n\n    var source = job.sourceCode;\n    var sourceLength = source.length;\n    // Index into source after the last code-unit recombined.\n    var sourceIndex = 0;\n\n    var spans = job.spans;\n    var nSpans = spans.length;\n    // Index into spans after the last span which ends at or before sourceIndex.\n    var spanIndex = 0;\n\n    var decorations = job.decorations;\n    var nDecorations = decorations.length;\n    // Index into decorations after the last decoration which ends at or before\n    // sourceIndex.\n    var decorationIndex = 0;\n\n    // Remove all zero-length decorations.\n    decorations[nDecorations] = sourceLength;\n    var decPos, i;\n    for (i = decPos = 0; i < nDecorations;) {\n      if (decorations[i] !== decorations[i + 2]) {\n        decorations[decPos++] = decorations[i++];\n        decorations[decPos++] = decorations[i++];\n      } else {\n        i += 2;\n      }\n    }\n    nDecorations = decPos;\n\n    // Simplify decorations.\n    for (i = decPos = 0; i < nDecorations;) {\n      var startPos = decorations[i];\n      // Conflate all adjacent decorations that use the same style.\n      var startDec = decorations[i + 1];\n      var end = i + 2;\n      while (end + 2 <= nDecorations && decorations[end + 1] === startDec) {\n        end += 2;\n      }\n      decorations[decPos++] = startPos;\n      decorations[decPos++] = startDec;\n      i = end;\n    }\n\n    nDecorations = decorations.length = decPos;\n\n    var sourceNode = job.sourceNode;\n    var oldDisplay = \"\";\n    if (sourceNode) {\n      oldDisplay = sourceNode.style.display;\n      sourceNode.style.display = 'none';\n    }\n    try {\n      var decoration = null;\n      while (spanIndex < nSpans) {\n        var spanStart = spans[spanIndex];\n        var spanEnd = /** @type{number} */ (spans[spanIndex + 2])\n            || sourceLength;\n\n        var decEnd = decorations[decorationIndex + 2] || sourceLength;\n\n        var end = Math.min(spanEnd, decEnd);\n\n        var textNode = /** @type{Node} */ (spans[spanIndex + 1]);\n        var styledText;\n        if (textNode.nodeType !== 1  // Don't muck with <BR>s or <LI>s\n            // Don't introduce spans around empty text nodes.\n            && (styledText = source.substring(sourceIndex, end))) {\n          // This may seem bizarre, and it is.  Emitting LF on IE causes the\n          // code to display with spaces instead of line breaks.\n          // Emitting Windows standard issue linebreaks (CRLF) causes a blank\n          // space to appear at the beginning of every line but the first.\n          // Emitting an old Mac OS 9 line separator makes everything spiffy.\n          if (isIE8OrEarlier) {\n            styledText = styledText.replace(newlineRe, '\\r');\n          }\n          textNode.nodeValue = styledText;\n          var document = textNode.ownerDocument;\n          var span = document.createElement('span');\n          span.className = decorations[decorationIndex + 1];\n          var parentNode = textNode.parentNode;\n          parentNode.replaceChild(span, textNode);\n          span.appendChild(textNode);\n          if (sourceIndex < spanEnd) {  // Split off a text node.\n            spans[spanIndex + 1] = textNode\n                // TODO: Possibly optimize by using '' if there's no flicker.\n                = document.createTextNode(source.substring(end, spanEnd));\n            parentNode.insertBefore(textNode, span.nextSibling);\n          }\n        }\n\n        sourceIndex = end;\n\n        if (sourceIndex >= spanEnd) {\n          spanIndex += 2;\n        }\n        if (sourceIndex >= decEnd) {\n          decorationIndex += 2;\n        }\n      }\n    } finally {\n      if (sourceNode) {\n        sourceNode.style.display = oldDisplay;\n      }\n    }\n  }\n\n\n  /** Maps language-specific file extensions to handlers. */\n  var langHandlerRegistry = {};\n  /** Register a language handler for the given file extensions.\n    * @param {function (JobT)} handler a function from source code to a list\n    *      of decorations.  Takes a single argument job which describes the\n    *      state of the computation and attaches the decorations to it.\n    * @param {Array.<string>} fileExtensions\n    */\n  function registerLangHandler(handler, fileExtensions) {\n    for (var i = fileExtensions.length; --i >= 0;) {\n      var ext = fileExtensions[i];\n      if (!langHandlerRegistry.hasOwnProperty(ext)) {\n        langHandlerRegistry[ext] = handler;\n      } else if (win['console']) {\n        console['warn']('cannot override language handler %s', ext);\n      }\n    }\n  }\n  function langHandlerForExtension(extension, source) {\n    if (!(extension && langHandlerRegistry.hasOwnProperty(extension))) {\n      // Treat it as markup if the first non whitespace character is a < and\n      // the last non-whitespace character is a >.\n      extension = /^\\s*</.test(source)\n          ? 'default-markup'\n          : 'default-code';\n    }\n    return langHandlerRegistry[extension];\n  }\n  registerLangHandler(decorateSource, ['default-code']);\n  registerLangHandler(\n      createSimpleLexer(\n          [],\n          [\n           [PR_PLAIN,       /^[^<?]+/],\n           [PR_DECLARATION, /^<!\\w[^>]*(?:>|$)/],\n           [PR_COMMENT,     /^<\\!--[\\s\\S]*?(?:-\\->|$)/],\n           // Unescaped content in an unknown language\n           ['lang-',        /^<\\?([\\s\\S]+?)(?:\\?>|$)/],\n           ['lang-',        /^<%([\\s\\S]+?)(?:%>|$)/],\n           [PR_PUNCTUATION, /^(?:<[%?]|[%?]>)/],\n           ['lang-',        /^<xmp\\b[^>]*>([\\s\\S]+?)<\\/xmp\\b[^>]*>/i],\n           // Unescaped content in javascript.  (Or possibly vbscript).\n           ['lang-js',      /^<script\\b[^>]*>([\\s\\S]*?)(<\\/script\\b[^>]*>)/i],\n           // Contains unescaped stylesheet content\n           ['lang-css',     /^<style\\b[^>]*>([\\s\\S]*?)(<\\/style\\b[^>]*>)/i],\n           ['lang-in.tag',  /^(<\\/?[a-z][^<>]*>)/i]\n          ]),\n      ['default-markup', 'htm', 'html', 'mxml', 'xhtml', 'xml', 'xsl']);\n  registerLangHandler(\n      createSimpleLexer(\n          [\n           [PR_PLAIN,        /^[\\s]+/, null, ' \\t\\r\\n'],\n           [PR_ATTRIB_VALUE, /^(?:\\\"[^\\\"]*\\\"?|\\'[^\\']*\\'?)/, null, '\\\"\\'']\n           ],\n          [\n           [PR_TAG,          /^^<\\/?[a-z](?:[\\w.:-]*\\w)?|\\/?>$/i],\n           [PR_ATTRIB_NAME,  /^(?!style[\\s=]|on)[a-z](?:[\\w:-]*\\w)?/i],\n           ['lang-uq.val',   /^=\\s*([^>\\'\\\"\\s]*(?:[^>\\'\\\"\\s\\/]|\\/(?=\\s)))/],\n           [PR_PUNCTUATION,  /^[=<>\\/]+/],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-js',       /^on\\w+\\s*=\\s*([^\\\"\\'>\\s]+)/i],\n           ['lang-css',      /^style\\s*=\\s*\\\"([^\\\"]+)\\\"/i],\n           ['lang-css',      /^style\\s*=\\s*\\'([^\\']+)\\'/i],\n           ['lang-css',      /^style\\s*=\\s*([^\\\"\\'>\\s]+)/i]\n           ]),\n      ['in.tag']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_ATTRIB_VALUE, /^[\\s\\S]+/]]), ['uq.val']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CPP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'types': C_TYPES\n        }), ['c', 'cc', 'cpp', 'cxx', 'cyc', 'm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': 'null,true,false'\n        }), ['json']);\n  registerLangHandler(sourceDecorator({\n          'keywords': CSHARP_KEYWORDS,\n          'hashComments': true,\n          'cStyleComments': true,\n          'verbatimStrings': true,\n          'types': C_TYPES\n        }), ['cs']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JAVA_KEYWORDS,\n          'cStyleComments': true\n        }), ['java']);\n  registerLangHandler(sourceDecorator({\n          'keywords': SH_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true\n        }), ['bash', 'bsh', 'csh', 'sh']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PYTHON_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'tripleQuotedStrings': true\n        }), ['cv', 'py', 'python']);\n  registerLangHandler(sourceDecorator({\n          'keywords': PERL_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': 2  // multiline regex literals\n        }), ['perl', 'pl', 'pm']);\n  registerLangHandler(sourceDecorator({\n          'keywords': RUBY_KEYWORDS,\n          'hashComments': true,\n          'multiLineStrings': true,\n          'regexLiterals': true\n        }), ['rb', 'ruby']);\n  registerLangHandler(sourceDecorator({\n          'keywords': JSCRIPT_KEYWORDS,\n          'cStyleComments': true,\n          'regexLiterals': true\n        }), ['javascript', 'js', 'ts', 'typescript']);\n  registerLangHandler(sourceDecorator({\n          'keywords': COFFEE_KEYWORDS,\n          'hashComments': 3,  // ### style block comments\n          'cStyleComments': true,\n          'multilineStrings': true,\n          'tripleQuotedStrings': true,\n          'regexLiterals': true\n        }), ['coffee']);\n  registerLangHandler(\n      createSimpleLexer([], [[PR_STRING, /^[\\s\\S]+/]]), ['regex']);\n\n  /** @param {JobT} job */\n  function applyDecorator(job) {\n    var opt_langExtension = job.langExtension;\n\n    try {\n      // Extract tags, and convert the source code to plain text.\n      var sourceAndSpans = extractSourceSpans(job.sourceNode, job.pre);\n      /** Plain text. @type {string} */\n      var source = sourceAndSpans.sourceCode;\n      job.sourceCode = source;\n      job.spans = sourceAndSpans.spans;\n      job.basePos = 0;\n\n      // Apply the appropriate language handler\n      langHandlerForExtension(opt_langExtension, source)(job);\n\n      // Integrate the decorations and tags back into the source code,\n      // modifying the sourceNode in place.\n      recombineTagsAndDecorations(job);\n    } catch (e) {\n      if (win['console']) {\n        console['log'](e && e['stack'] || e);\n      }\n    }\n  }\n\n  /**\n   * Pretty print a chunk of code.\n   * @param sourceCodeHtml {string} The HTML to pretty print.\n   * @param opt_langExtension {string} The language name to use.\n   *     Typically, a filename extension like 'cpp' or 'java'.\n   * @param opt_numberLines {number|boolean} True to number lines,\n   *     or the 1-indexed number of the first line in sourceCodeHtml.\n   */\n  function $prettyPrintOne(sourceCodeHtml, opt_langExtension, opt_numberLines) {\n    /** @type{number|boolean} */\n    var nl = opt_numberLines || false;\n    /** @type{string|null} */\n    var langExtension = opt_langExtension || null;\n    /** @type{!Element} */\n    var container = document.createElement('div');\n    // This could cause images to load and onload listeners to fire.\n    // E.g. <img onerror=\"alert(1337)\" src=\"nosuchimage.png\">.\n    // We assume that the inner HTML is from a trusted source.\n    // The pre-tag is required for IE8 which strips newlines from innerHTML\n    // when it is injected into a <pre> tag.\n    // http://stackoverflow.com/questions/451486/pre-tag-loses-line-breaks-when-setting-innerhtml-in-ie\n    // http://stackoverflow.com/questions/195363/inserting-a-newline-into-a-pre-tag-ie-javascript\n    container.innerHTML = '<pre>' + sourceCodeHtml + '</pre>';\n    container = /** @type{!Element} */(container.firstChild);\n    if (nl) {\n      numberLines(container, nl, true);\n    }\n\n    /** @type{JobT} */\n    var job = {\n      langExtension: langExtension,\n      numberLines: nl,\n      sourceNode: container,\n      pre: 1,\n      sourceCode: null,\n      basePos: null,\n      spans: null,\n      decorations: null\n    };\n    applyDecorator(job);\n    return container.innerHTML;\n  }\n\n   /**\n    * Find all the {@code <pre>} and {@code <code>} tags in the DOM with\n    * {@code class=prettyprint} and prettify them.\n    *\n    * @param {Function} opt_whenDone called when prettifying is done.\n    * @param {HTMLElement|HTMLDocument} opt_root an element or document\n    *   containing all the elements to pretty print.\n    *   Defaults to {@code document.body}.\n    */\n  function $prettyPrint(opt_whenDone, opt_root) {\n    var root = opt_root || document.body;\n    var doc = root.ownerDocument || document;\n    function byTagName(tn) { return root.getElementsByTagName(tn); }\n    // fetch a list of nodes to rewrite\n    var codeSegments = [byTagName('pre'), byTagName('code'), byTagName('xmp')];\n    var elements = [];\n    for (var i = 0; i < codeSegments.length; ++i) {\n      for (var j = 0, n = codeSegments[i].length; j < n; ++j) {\n        elements.push(codeSegments[i][j]);\n      }\n    }\n    codeSegments = null;\n\n    var clock = Date;\n    if (!clock['now']) {\n      clock = { 'now': function () { return +(new Date); } };\n    }\n\n    // The loop is broken into a series of continuations to make sure that we\n    // don't make the browser unresponsive when rewriting a large page.\n    var k = 0;\n\n    var langExtensionRe = /\\blang(?:uage)?-([\\w.]+)(?!\\S)/;\n    var prettyPrintRe = /\\bprettyprint\\b/;\n    var prettyPrintedRe = /\\bprettyprinted\\b/;\n    var preformattedTagNameRe = /pre|xmp/i;\n    var codeRe = /^code$/i;\n    var preCodeXmpRe = /^(?:pre|code|xmp)$/i;\n    var EMPTY = {};\n\n    function doWork() {\n      var endTime = (win['PR_SHOULD_USE_CONTINUATION'] ?\n                     clock['now']() + 250 /* ms */ :\n                     Infinity);\n      for (; k < elements.length && clock['now']() < endTime; k++) {\n        var cs = elements[k];\n\n        // Look for a preceding comment like\n        // <?prettify lang=\"...\" linenums=\"...\"?>\n        var attrs = EMPTY;\n        {\n          for (var preceder = cs; (preceder = preceder.previousSibling);) {\n            var nt = preceder.nodeType;\n            // <?foo?> is parsed by HTML 5 to a comment node (8)\n            // like <!--?foo?-->, but in XML is a processing instruction\n            var value = (nt === 7 || nt === 8) && preceder.nodeValue;\n            if (value\n                ? !/^\\??prettify\\b/.test(value)\n                : (nt !== 3 || /\\S/.test(preceder.nodeValue))) {\n              // Skip over white-space text nodes but not others.\n              break;\n            }\n            if (value) {\n              attrs = {};\n              value.replace(\n                  /\\b(\\w+)=([\\w:.%+-]+)/g,\n                function (_, name, value) { attrs[name] = value; });\n              break;\n            }\n          }\n        }\n\n        var className = cs.className;\n        if ((attrs !== EMPTY || prettyPrintRe.test(className))\n            // Don't redo this if we've already done it.\n            // This allows recalling pretty print to just prettyprint elements\n            // that have been added to the page since last call.\n            && !prettyPrintedRe.test(className)) {\n\n          // make sure this is not nested in an already prettified element\n          var nested = false;\n          for (var p = cs.parentNode; p; p = p.parentNode) {\n            var tn = p.tagName;\n            if (preCodeXmpRe.test(tn)\n                && p.className && prettyPrintRe.test(p.className)) {\n              nested = true;\n              break;\n            }\n          }\n          if (!nested) {\n            // Mark done.  If we fail to prettyprint for whatever reason,\n            // we shouldn't try again.\n            cs.className += ' prettyprinted';\n\n            // If the classes includes a language extensions, use it.\n            // Language extensions can be specified like\n            //     <pre class=\"prettyprint lang-cpp\">\n            // the language extension \"cpp\" is used to find a language handler\n            // as passed to PR.registerLangHandler.\n            // HTML5 recommends that a language be specified using \"language-\"\n            // as the prefix instead.  Google Code Prettify supports both.\n            // http://dev.w3.org/html5/spec-author-view/the-code-element.html\n            var langExtension = attrs['lang'];\n            if (!langExtension) {\n              langExtension = className.match(langExtensionRe);\n              // Support <pre class=\"prettyprint\"><code class=\"language-c\">\n              var wrapper;\n              if (!langExtension && (wrapper = childContentWrapper(cs))\n                  && codeRe.test(wrapper.tagName)) {\n                langExtension = wrapper.className.match(langExtensionRe);\n              }\n\n              if (langExtension) { langExtension = langExtension[1]; }\n            }\n\n            var preformatted;\n            if (preformattedTagNameRe.test(cs.tagName)) {\n              preformatted = 1;\n            } else {\n              var currentStyle = cs['currentStyle'];\n              var defaultView = doc.defaultView;\n              var whitespace = (\n                  currentStyle\n                  ? currentStyle['whiteSpace']\n                  : (defaultView\n                     && defaultView.getComputedStyle)\n                  ? defaultView.getComputedStyle(cs, null)\n                  .getPropertyValue('white-space')\n                  : 0);\n              preformatted = whitespace\n                  && 'pre' === whitespace.substring(0, 3);\n            }\n\n            // Look for a class like linenums or linenums:<n> where <n> is the\n            // 1-indexed number of the first line.\n            var lineNums = attrs['linenums'];\n            if (!(lineNums = lineNums === 'true' || +lineNums)) {\n              lineNums = className.match(/\\blinenums\\b(?::(\\d+))?/);\n              lineNums =\n                lineNums\n                ? lineNums[1] && lineNums[1].length\n                  ? +lineNums[1] : true\n                : false;\n            }\n            if (lineNums) { numberLines(cs, lineNums, preformatted); }\n\n            // do the pretty printing\n            var prettyPrintingJob = {\n              langExtension: langExtension,\n              sourceNode: cs,\n              numberLines: lineNums,\n              pre: preformatted,\n              sourceCode: null,\n              basePos: null,\n              spans: null,\n              decorations: null\n            };\n            applyDecorator(prettyPrintingJob);\n          }\n        }\n      }\n      if (k < elements.length) {\n        // finish up in a continuation\n        win.setTimeout(doWork, 250);\n      } else if ('function' === typeof opt_whenDone) {\n        opt_whenDone();\n      }\n    }\n\n    doWork();\n  }\n\n  /**\n   * Contains functions for creating and registering new language handlers.\n   * @type {Object}\n   */\n  var PR = win['PR'] = {\n        'createSimpleLexer': createSimpleLexer,\n        'registerLangHandler': registerLangHandler,\n        'sourceDecorator': sourceDecorator,\n        'PR_ATTRIB_NAME': PR_ATTRIB_NAME,\n        'PR_ATTRIB_VALUE': PR_ATTRIB_VALUE,\n        'PR_COMMENT': PR_COMMENT,\n        'PR_DECLARATION': PR_DECLARATION,\n        'PR_KEYWORD': PR_KEYWORD,\n        'PR_LITERAL': PR_LITERAL,\n        'PR_NOCODE': PR_NOCODE,\n        'PR_PLAIN': PR_PLAIN,\n        'PR_PUNCTUATION': PR_PUNCTUATION,\n        'PR_SOURCE': PR_SOURCE,\n        'PR_STRING': PR_STRING,\n        'PR_TAG': PR_TAG,\n        'PR_TYPE': PR_TYPE,\n        'prettyPrintOne':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrintOne'] = $prettyPrintOne)\n             : (prettyPrintOne = $prettyPrintOne),\n        'prettyPrint':\n           IN_GLOBAL_SCOPE\n             ? (win['prettyPrint'] = $prettyPrint)\n             : (prettyPrint = $prettyPrint)\n      };\n\n  // Make PR available via the Asynchronous Module Definition (AMD) API.\n  // Per https://github.com/amdjs/amdjs-api/wiki/AMD:\n  // The Asynchronous Module Definition (AMD) API specifies a\n  // mechanism for defining modules such that the module and its\n  // dependencies can be asynchronously loaded.\n  // ...\n  // To allow a clear indicator that a global define function (as\n  // needed for script src browser loading) conforms to the AMD API,\n  // any global define function SHOULD have a property called \"amd\"\n  // whose value is an object. This helps avoid conflict with any\n  // other existing JavaScript code that could have defined a define()\n  // function that does not conform to the AMD API.\n  var define = win['define'];\n  if (typeof define === \"function\" && define['amd']) {\n    define(\"google-code-prettify\", [], function () {\n      return PR;\n    });\n  }\n})();\n"}],"Post":[{"title":"Kubernetes集群搭建","date":"2021-09-14T06:35:42.000Z","updated":"2021-09-14T07:24:00.000Z","comments":1,"_content":"\n这次打算尝试使用`kubeadm`来从头搭建一个`Kubernetes集群`，并且记录下整个过程以及中途遇到的问题。\n\n# 准备工作\n\n这次的搭建需要两台虚拟机，一台作为`Master节点`而另一台作为`Node节点`方便后续进行更多的集群相关的测试。\n\n云服务器：\n\n-   AWS t2.large(2vCPU 8GiB) \\*2\n\n搭建工具：\n\n-   kubeadm\n\nkubeadm 是一个可以帮助一键搭建 Kubernetes 集群的工具。\n\n# 搭建 Master 节点\n\n## #1 安装 kubeadm 以及相关工具\n\n首先需要配置云服务器，安装需要的工具。\n\n```bash\n$sudo apt-get update\n$sudo apt-get install gnupg\n$curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\nOK\n```\n\n需要将 Kubernetes 官方源添加到本地。\n\n```\n#/etc/apt/sources.list.d/kubernetes.list\ndeb http://apt.kubernetes.io/ kubernetes-xenial main\n```\n\n将以上文件（/etc/apt/sources.list.d/kubernetes.list）添加了之后，运行以下命令可以看到此时 Kubernetes 的源已经被添加进来。\n\n```bash\n$sudo apt-get update\n\n...\nGet:4 https://packages.cloud.google.com/apt kubernetes-xenial InRelease [9383 B]\nGet:6 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 Packages [49.4 kB]\n...\n```\n\n在完成了以上的配置之后即可开始安装`kubelet`，`kubectl`以及`kubeadm`\n\n`kubeadm`需要使用`kubelet`服务来以容器方式部署和启动 Kubernetes 的主要服务，所以需要安装并先启动 kubelet 服务。\n而`kubectl`则是客户端命令行工具，在集群搭建完成之后可以通过它查看集群信息与状态。\n\n```bash\n# 安装kubelet，kubectl以及kubeadm\n$sudo apt-get install kubelet kubectl kubeadm\n```\n\n要启动 kubelet 需要先安装并启动`docker`\n\n```bash\n$curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -\nOK\n\n# 要安装了 software-properties-common 才能使用 add-apt-repository\n$sudo apt-get install software-properties-common\n$sudo add-apt-repository \\\n\"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \\\n$(lsb_release -cs) \\\nstable\"\n$sudo apt-get update\n# 安装docker\n$sudo apt-get install docker-ce\n```\n\n完成了以上所需工具的安装后就可以开始按顺序启动它们。\n\n```bash\n#启动docker\n$systemctl start docker\n```\n\n在 docker正常启动并确定docker的`cgroup driver`为`systemd`后（详情可见`错误及解决方案 #2`），可开始安装`Master节点`。\n\n此时如果用`systemctl status kubelet`命令查看`kubelet`状态，可发现kubelet没有正常启动，报错为：\n```\n \"Failed to load kubelet config file\" err=\"failed to load Kubelet config file...\n```\n这是因为还没有运行 `kubeadm init`命令，在这个命令运行了之后，`kubelet`的配置文件会被生成，`kubelet`也会自动重启并正常运行。\n\n## #2 使用 kubeadm 安装 Master 节点\n\n使用`kubeadm config`命令打印`kubeadm`的默认配置.\n\n```bash\n#输出kubeadm默认配置\n$kubeadm config print init-defaults\n#将kubeadm默认配置保存到文件中方便做自定义修改\n$kubeadm config print init-defaults >> init.default.yaml\n```\n\n以下是`kubeadm`打印出来的默认配置:\n\n```\n#init.default.yaml\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n\n-   groups:\n    -   system:bootstrappers:kubeadm:default-node-token\n        token: abcdef.0123456789abcdef\n        ttl: 24h0m0s\n        usages:\n    -   signing\n    -   authentication\n        kind: InitConfiguration\n        localAPIEndpoint:\n        advertiseAddress: 1.2.3.4\n        bindPort: 6443\n        nodeRegistration:\n        criSocket: /var/run/dockershim.sock\n        imagePullPolicy: IfNotPresent\n        name: node\n        taints: null\n\n---\n\napiServer:\ntimeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io/v1beta3\ncertificatesDir: /etc/kubernetes/pki\nclusterName: kubernetes\ncontrollerManager: {}\ndns: {}\netcd:\nlocal:\ndataDir: /var/lib/etcd\nimageRepository: k8s.gcr.io\nkind: ClusterConfiguration\nkubernetesVersion: 1.22.0\nnetworking:\ndnsDomain: cluster.local\nserviceSubnet: 10.96.0.0/12\nscheduler: {}\n```\n\n用以下命令可以查看镜像列表:\n\n```bash\n$kubeadm config images list\nk8s.gcr.io/kube-apiserver:v1.22.1\nk8s.gcr.io/kube-controller-manager:v1.22.1\nk8s.gcr.io/kube-scheduler:v1.22.1\nk8s.gcr.io/kube-proxy:v1.22.1\nk8s.gcr.io/pause:3.5\nk8s.gcr.io/etcd:3.5.0-0\nk8s.gcr.io/coredns/coredns:v1.8.4\n```\n\n可以使用`kubeadm config images pull`命令将这些镜像提前拉下来。就算不提前拉取，在后续步骤运行`kubeadm init`命令的时候也会自动进行拉取。\n\n使用以下命令就可直接安装 Master 节点：\n\n```bash\n$sudo kubeadm init --pod-network-cidr=172.30.0.0/16\n```\n\n这里注意一定要加上后面的`—pod-network-cidr`参数，否则在安装 flannel（网络插件）时会报以下错误：\n\n```\nE0913 19:45:12.323393 1 main.go:293] Error registering network: failed to acquire lease: node \"ip-172-31-40-163\" pod cidr not assigned\n```\n\n这次我没有修改默认的配置，如果有自定义配置，可以运行\n\n```bash\n$sudo kubeadm init –config=<config_file_path>\n```\n\n安装完成后会得到以下相关提示:\n\n```\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\nmkdir -p $HOME/.kube\n  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n  sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\nAlternatively, if you are the root user, you can run:\n\nexport KUBECONFIG=/etc/kubernetes/admin.conf\n\nYou should now deploy a pod network to the cluster.\nRun \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:\nhttps://kubernetes.io/docs/concepts/cluster-administration/addons/\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf\n```\n\n根据提示可以运行以下命令，这些命令是为了方便用户通过`kubectl`访问集群，`config`文件里配置了访问集群的入口，用户以及 token 等。\n\n```bash\n$mkdir -p $HOME/.kube\n$sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n$sudo chown $(id -u):$(id -g) $HOME/.kube/config\n```\n\n完成配置后就可以使用 kubectl 访问集群了。\n\n使用`kubectl get node`可以看到，目前`master node`的状态是`Not Ready`。\n\n```\nNAME             STATUS     ROLES                AGE    VERSION\nip-172-31-40-163 NotReady   control-plane,master 14m    v1.22.1\n```\n\n使用`kubectl get node <node_name> -o yaml`(或者`kubectl describe node <node_name>`)可以查看具体原因：\n\n```yaml\n...\nmessage: 'container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady\nmessage:docker: network plugin is not ready: cni config uninitialized'\nreason: KubeletNotReady\nstatus: \"False\"\n...\n```\n\n这是由于`kubeadm`的安装过程**不涉及**`网络插件（CNI)`的初始化，所以集群没有网络功能。\n\n```bash\n$kubectl get pod --all-namespaces\nNAMESPACE   NAME                        READY   STATUS  RESTARTS AGE\nkube-system coredns-78fcd69978-59b4t     0/1     Pending 0       10m\nkube-system coredns-78fcd69978-hc8qn     0/1     Pending 0       10m\nkube-system etcd-ip-172-31-40-163        1/1     Running 3       10m\nkube-system kube-apiserver-ip-172-...    1/1     Running 2       10m\nkube-system kube-controller-manager-...  1/1     Running 2       10m\nkube-system kube-proxy-dzklf             1/1     Running 0       10m\nkube-system kube-scheduler-ip-172-...    1/1     Running 3       10m\n```\n\n可以观察到`kubadm`已经为`master 节点`启动了`coredns`,`etcd`,`kube-apiserver`,`kube-controller-manager`,`kube-proxy`以及 `kube-scheduler`了。\n并且与网络相关`coredns`由于没有网络也无法正常启动。\n\n## #3 安装网络插件 Flannel\n\n首先下载在 Kubernetes 集群内安装`flanner`所需的配置文件，里面包括了启动该服务所需的所有资源的配置\n\n```bash\n$wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n```\n\n使用下载的 Yaml 文件在集群内启动所有相关资源\n\n```bash\n$kubectl apply -f kube-flannel.yml\n\npodsecuritypolicy.policy/psp.flannel.unprivileged created\nclusterrole.rbac.authorization.k8s.io/flannel created\nclusterrolebinding.rbac.authorization.k8s.io/flannel created\nserviceaccount/flannel created\nconfigmap/kube-flannel-cfg created\ndaemonset.apps/kube-flannel-ds created\n```\n\n现在查看`pod`的状态可以发现所有的`pod`都正常运行(`Running`)中\n\n```bash\n$ kubectl get pod --all-namespaces\nNAMESPACE NAME READY STATUS RESTARTS AGE\nkube-system coredns-78fcd69978-xx27f 1/1 Running 0 3m40s\nkube-system coredns-78fcd69978-zxnw5 1/1 Running 0 3m40s\nkube-system etcd-ip-172-31-40-163 1/1 Running 4 3m54s\nkube-system kube-apiserver-ip-172-31-40-163 1/1 Running 3 3m54s\nkube-system kube-controller-manager-ip-172-31-40-163 1/1 Running 0 3m57s\nkube-system kube-flannel-ds-26tcn 1/1 Running 0 5s\nkube-system kube-proxy-8c4md 1/1 Running 0 3m40s\nkube-system kube-scheduler-ip-172-31-40-163 1/1 Running 4 3m54s\n```\n\n而`master 节点`也切换到了`Ready`的状态\n\n```bash\n$ kubectl get node\nNAME                STATUS  ROLES                   AGE     VERSION\nip-172-31-40-163    Ready   control-plane,master    4m47s   v1.22.1\n```\n\n# 搭建 Node 节点\n重复以上在`Master节点`中安装`kubeadm`等工具的过程。\n\n运行`kubeadm`在`Master 节点`安装完成后返回的将`worker 节点`加入集群的命令:\n\n```bash\n$kubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf\n```\n\n如果在创建 `Master节点`后忘记了以上命令及token，则可用`kubeadm token create --print-join-command`命令重新生成token并输出完整的`join`命令。\n\n在以上命令成功运行后，在`Master节点`通过`kubectl get node`可观察到，集群已有两个节点：\n\n```bash\n$kubectl get node\n\nNAME               STATUS   ROLES                  AGE   VERSION\nip-172-31-40-163   Ready    control-plane,master   23h   v1.22.1\nip-172-31-47-241   Ready    <none>                 15s   v1.22.1\n```\n\n# 错误及解决方案\n\n## #1 docker 连接 Docker daemon socket 失败\n\n运行`docker info`命令时得到以下错误：\n\n```\nERROR: Got permission denied while trying to connect to the Docker daemon socket ...\n```\n\n需要确认 docker 组已经创建并且当前使用的用户在这个组内。\n\n```bash\n$sudo groupadd docker\n$sudo gpasswd -a <username> docker\n$newgrp docker\n$systemctl restart docker\n```\n\n完成以上步骤后，再次运行`docker info`命令可以正确得到所需信息。\n\n## #2 Kubelet 启动失败\n\n用`systemctl status kubelet`命令获得进程号后，再用`journalctl \\_PID=<进程号>|vim – `查看日志，获得了以下信息：\n\n```bash\nSep 13 17:30:09 ip-172-31-40-163 kubelet[18094]: E0913 17:30:09.620375 18094 server.go:294] \"Failed to run kubelet\" err=\"failed to run Kubelet: misconfiguration: kubelet cgroup driver: \\\"systemd\\\" is different from docker cgroup driver: \\\"cgroupfs\\\"\"\n```\n\n原因是`docker`和`kubelet`使用的`cgroup driver`不一样，一个是`systemd`，一个是`cgroupfs`。根据 Kubernetes 官网文档：\n\n> `systemd driver` is **recommended** for `kubeadm` based setups instead of the `cgroupfs driver`, because kubeadm manages the kubelet as a systemd service.\n\n`systemd`是比较推荐的,也是 kubeadm 默认设置的 cgroup drive。（据说 systemd 更安全）所以这里我统一设置成使用 systemd。也就是需要把 `docker` 的`cgroup driver`更改成`systemd`\n\n修改`/etc/docker/daemon.json`（或创建）\n\n```\n#/etc/docker/daemon.json\n{\n\"exec-opts\":[\"native.cgroupdriver=systemd\"]\n}\n```\n\n在完成修改之后，用以下命令更新配置并重启 docker\n\n```bash\n$systemctl daemon-reload\n$systemctl restart docker\n```\n\n重启后使用`docker info`命令可获得 docker 的所有相关信息,可以确认 docker 的`cgroup driver`已经换成了`systemd`。\n\n```bash\n$ docker info\n\n...\nLogging Driver: json-file\nCgroup Driver: systemd\nCgroup Version: 1\n...\n\n```\n\n此时再确认 kubelet 的状态可以看到 kubelet 已经自动重启并正常运行。","source":"_posts/Kubernetes集群搭建.md","raw":"---\ntitle: Kubernetes集群搭建\ndate: 2021-09-14 14:35:42\nupdated: 2021-09-14 15:24:00\ntags:\n    - Kubernetes\ncategories:\ncomments: true\n---\n\n这次打算尝试使用`kubeadm`来从头搭建一个`Kubernetes集群`，并且记录下整个过程以及中途遇到的问题。\n\n# 准备工作\n\n这次的搭建需要两台虚拟机，一台作为`Master节点`而另一台作为`Node节点`方便后续进行更多的集群相关的测试。\n\n云服务器：\n\n-   AWS t2.large(2vCPU 8GiB) \\*2\n\n搭建工具：\n\n-   kubeadm\n\nkubeadm 是一个可以帮助一键搭建 Kubernetes 集群的工具。\n\n# 搭建 Master 节点\n\n## #1 安装 kubeadm 以及相关工具\n\n首先需要配置云服务器，安装需要的工具。\n\n```bash\n$sudo apt-get update\n$sudo apt-get install gnupg\n$curl -s https://packages.cloud.google.com/apt/doc/apt-key.gpg | sudo apt-key add -\nOK\n```\n\n需要将 Kubernetes 官方源添加到本地。\n\n```\n#/etc/apt/sources.list.d/kubernetes.list\ndeb http://apt.kubernetes.io/ kubernetes-xenial main\n```\n\n将以上文件（/etc/apt/sources.list.d/kubernetes.list）添加了之后，运行以下命令可以看到此时 Kubernetes 的源已经被添加进来。\n\n```bash\n$sudo apt-get update\n\n...\nGet:4 https://packages.cloud.google.com/apt kubernetes-xenial InRelease [9383 B]\nGet:6 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 Packages [49.4 kB]\n...\n```\n\n在完成了以上的配置之后即可开始安装`kubelet`，`kubectl`以及`kubeadm`\n\n`kubeadm`需要使用`kubelet`服务来以容器方式部署和启动 Kubernetes 的主要服务，所以需要安装并先启动 kubelet 服务。\n而`kubectl`则是客户端命令行工具，在集群搭建完成之后可以通过它查看集群信息与状态。\n\n```bash\n# 安装kubelet，kubectl以及kubeadm\n$sudo apt-get install kubelet kubectl kubeadm\n```\n\n要启动 kubelet 需要先安装并启动`docker`\n\n```bash\n$curl -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg | sudo apt-key add -\nOK\n\n# 要安装了 software-properties-common 才能使用 add-apt-repository\n$sudo apt-get install software-properties-common\n$sudo add-apt-repository \\\n\"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \\\n$(lsb_release -cs) \\\nstable\"\n$sudo apt-get update\n# 安装docker\n$sudo apt-get install docker-ce\n```\n\n完成了以上所需工具的安装后就可以开始按顺序启动它们。\n\n```bash\n#启动docker\n$systemctl start docker\n```\n\n在 docker正常启动并确定docker的`cgroup driver`为`systemd`后（详情可见`错误及解决方案 #2`），可开始安装`Master节点`。\n\n此时如果用`systemctl status kubelet`命令查看`kubelet`状态，可发现kubelet没有正常启动，报错为：\n```\n \"Failed to load kubelet config file\" err=\"failed to load Kubelet config file...\n```\n这是因为还没有运行 `kubeadm init`命令，在这个命令运行了之后，`kubelet`的配置文件会被生成，`kubelet`也会自动重启并正常运行。\n\n## #2 使用 kubeadm 安装 Master 节点\n\n使用`kubeadm config`命令打印`kubeadm`的默认配置.\n\n```bash\n#输出kubeadm默认配置\n$kubeadm config print init-defaults\n#将kubeadm默认配置保存到文件中方便做自定义修改\n$kubeadm config print init-defaults >> init.default.yaml\n```\n\n以下是`kubeadm`打印出来的默认配置:\n\n```\n#init.default.yaml\napiVersion: kubeadm.k8s.io/v1beta3\nbootstrapTokens:\n\n-   groups:\n    -   system:bootstrappers:kubeadm:default-node-token\n        token: abcdef.0123456789abcdef\n        ttl: 24h0m0s\n        usages:\n    -   signing\n    -   authentication\n        kind: InitConfiguration\n        localAPIEndpoint:\n        advertiseAddress: 1.2.3.4\n        bindPort: 6443\n        nodeRegistration:\n        criSocket: /var/run/dockershim.sock\n        imagePullPolicy: IfNotPresent\n        name: node\n        taints: null\n\n---\n\napiServer:\ntimeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io/v1beta3\ncertificatesDir: /etc/kubernetes/pki\nclusterName: kubernetes\ncontrollerManager: {}\ndns: {}\netcd:\nlocal:\ndataDir: /var/lib/etcd\nimageRepository: k8s.gcr.io\nkind: ClusterConfiguration\nkubernetesVersion: 1.22.0\nnetworking:\ndnsDomain: cluster.local\nserviceSubnet: 10.96.0.0/12\nscheduler: {}\n```\n\n用以下命令可以查看镜像列表:\n\n```bash\n$kubeadm config images list\nk8s.gcr.io/kube-apiserver:v1.22.1\nk8s.gcr.io/kube-controller-manager:v1.22.1\nk8s.gcr.io/kube-scheduler:v1.22.1\nk8s.gcr.io/kube-proxy:v1.22.1\nk8s.gcr.io/pause:3.5\nk8s.gcr.io/etcd:3.5.0-0\nk8s.gcr.io/coredns/coredns:v1.8.4\n```\n\n可以使用`kubeadm config images pull`命令将这些镜像提前拉下来。就算不提前拉取，在后续步骤运行`kubeadm init`命令的时候也会自动进行拉取。\n\n使用以下命令就可直接安装 Master 节点：\n\n```bash\n$sudo kubeadm init --pod-network-cidr=172.30.0.0/16\n```\n\n这里注意一定要加上后面的`—pod-network-cidr`参数，否则在安装 flannel（网络插件）时会报以下错误：\n\n```\nE0913 19:45:12.323393 1 main.go:293] Error registering network: failed to acquire lease: node \"ip-172-31-40-163\" pod cidr not assigned\n```\n\n这次我没有修改默认的配置，如果有自定义配置，可以运行\n\n```bash\n$sudo kubeadm init –config=<config_file_path>\n```\n\n安装完成后会得到以下相关提示:\n\n```\nYour Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\nmkdir -p $HOME/.kube\n  sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n  sudo chown $(id -u):$(id -g) $HOME/.kube/config\n\nAlternatively, if you are the root user, you can run:\n\nexport KUBECONFIG=/etc/kubernetes/admin.conf\n\nYou should now deploy a pod network to the cluster.\nRun \"kubectl apply -f [podnetwork].yaml\" with one of the options listed at:\nhttps://kubernetes.io/docs/concepts/cluster-administration/addons/\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf\n```\n\n根据提示可以运行以下命令，这些命令是为了方便用户通过`kubectl`访问集群，`config`文件里配置了访问集群的入口，用户以及 token 等。\n\n```bash\n$mkdir -p $HOME/.kube\n$sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config\n$sudo chown $(id -u):$(id -g) $HOME/.kube/config\n```\n\n完成配置后就可以使用 kubectl 访问集群了。\n\n使用`kubectl get node`可以看到，目前`master node`的状态是`Not Ready`。\n\n```\nNAME             STATUS     ROLES                AGE    VERSION\nip-172-31-40-163 NotReady   control-plane,master 14m    v1.22.1\n```\n\n使用`kubectl get node <node_name> -o yaml`(或者`kubectl describe node <node_name>`)可以查看具体原因：\n\n```yaml\n...\nmessage: 'container runtime network not ready: NetworkReady=false reason:NetworkPluginNotReady\nmessage:docker: network plugin is not ready: cni config uninitialized'\nreason: KubeletNotReady\nstatus: \"False\"\n...\n```\n\n这是由于`kubeadm`的安装过程**不涉及**`网络插件（CNI)`的初始化，所以集群没有网络功能。\n\n```bash\n$kubectl get pod --all-namespaces\nNAMESPACE   NAME                        READY   STATUS  RESTARTS AGE\nkube-system coredns-78fcd69978-59b4t     0/1     Pending 0       10m\nkube-system coredns-78fcd69978-hc8qn     0/1     Pending 0       10m\nkube-system etcd-ip-172-31-40-163        1/1     Running 3       10m\nkube-system kube-apiserver-ip-172-...    1/1     Running 2       10m\nkube-system kube-controller-manager-...  1/1     Running 2       10m\nkube-system kube-proxy-dzklf             1/1     Running 0       10m\nkube-system kube-scheduler-ip-172-...    1/1     Running 3       10m\n```\n\n可以观察到`kubadm`已经为`master 节点`启动了`coredns`,`etcd`,`kube-apiserver`,`kube-controller-manager`,`kube-proxy`以及 `kube-scheduler`了。\n并且与网络相关`coredns`由于没有网络也无法正常启动。\n\n## #3 安装网络插件 Flannel\n\n首先下载在 Kubernetes 集群内安装`flanner`所需的配置文件，里面包括了启动该服务所需的所有资源的配置\n\n```bash\n$wget https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml\n```\n\n使用下载的 Yaml 文件在集群内启动所有相关资源\n\n```bash\n$kubectl apply -f kube-flannel.yml\n\npodsecuritypolicy.policy/psp.flannel.unprivileged created\nclusterrole.rbac.authorization.k8s.io/flannel created\nclusterrolebinding.rbac.authorization.k8s.io/flannel created\nserviceaccount/flannel created\nconfigmap/kube-flannel-cfg created\ndaemonset.apps/kube-flannel-ds created\n```\n\n现在查看`pod`的状态可以发现所有的`pod`都正常运行(`Running`)中\n\n```bash\n$ kubectl get pod --all-namespaces\nNAMESPACE NAME READY STATUS RESTARTS AGE\nkube-system coredns-78fcd69978-xx27f 1/1 Running 0 3m40s\nkube-system coredns-78fcd69978-zxnw5 1/1 Running 0 3m40s\nkube-system etcd-ip-172-31-40-163 1/1 Running 4 3m54s\nkube-system kube-apiserver-ip-172-31-40-163 1/1 Running 3 3m54s\nkube-system kube-controller-manager-ip-172-31-40-163 1/1 Running 0 3m57s\nkube-system kube-flannel-ds-26tcn 1/1 Running 0 5s\nkube-system kube-proxy-8c4md 1/1 Running 0 3m40s\nkube-system kube-scheduler-ip-172-31-40-163 1/1 Running 4 3m54s\n```\n\n而`master 节点`也切换到了`Ready`的状态\n\n```bash\n$ kubectl get node\nNAME                STATUS  ROLES                   AGE     VERSION\nip-172-31-40-163    Ready   control-plane,master    4m47s   v1.22.1\n```\n\n# 搭建 Node 节点\n重复以上在`Master节点`中安装`kubeadm`等工具的过程。\n\n运行`kubeadm`在`Master 节点`安装完成后返回的将`worker 节点`加入集群的命令:\n\n```bash\n$kubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf\n```\n\n如果在创建 `Master节点`后忘记了以上命令及token，则可用`kubeadm token create --print-join-command`命令重新生成token并输出完整的`join`命令。\n\n在以上命令成功运行后，在`Master节点`通过`kubectl get node`可观察到，集群已有两个节点：\n\n```bash\n$kubectl get node\n\nNAME               STATUS   ROLES                  AGE   VERSION\nip-172-31-40-163   Ready    control-plane,master   23h   v1.22.1\nip-172-31-47-241   Ready    <none>                 15s   v1.22.1\n```\n\n# 错误及解决方案\n\n## #1 docker 连接 Docker daemon socket 失败\n\n运行`docker info`命令时得到以下错误：\n\n```\nERROR: Got permission denied while trying to connect to the Docker daemon socket ...\n```\n\n需要确认 docker 组已经创建并且当前使用的用户在这个组内。\n\n```bash\n$sudo groupadd docker\n$sudo gpasswd -a <username> docker\n$newgrp docker\n$systemctl restart docker\n```\n\n完成以上步骤后，再次运行`docker info`命令可以正确得到所需信息。\n\n## #2 Kubelet 启动失败\n\n用`systemctl status kubelet`命令获得进程号后，再用`journalctl \\_PID=<进程号>|vim – `查看日志，获得了以下信息：\n\n```bash\nSep 13 17:30:09 ip-172-31-40-163 kubelet[18094]: E0913 17:30:09.620375 18094 server.go:294] \"Failed to run kubelet\" err=\"failed to run Kubelet: misconfiguration: kubelet cgroup driver: \\\"systemd\\\" is different from docker cgroup driver: \\\"cgroupfs\\\"\"\n```\n\n原因是`docker`和`kubelet`使用的`cgroup driver`不一样，一个是`systemd`，一个是`cgroupfs`。根据 Kubernetes 官网文档：\n\n> `systemd driver` is **recommended** for `kubeadm` based setups instead of the `cgroupfs driver`, because kubeadm manages the kubelet as a systemd service.\n\n`systemd`是比较推荐的,也是 kubeadm 默认设置的 cgroup drive。（据说 systemd 更安全）所以这里我统一设置成使用 systemd。也就是需要把 `docker` 的`cgroup driver`更改成`systemd`\n\n修改`/etc/docker/daemon.json`（或创建）\n\n```\n#/etc/docker/daemon.json\n{\n\"exec-opts\":[\"native.cgroupdriver=systemd\"]\n}\n```\n\n在完成修改之后，用以下命令更新配置并重启 docker\n\n```bash\n$systemctl daemon-reload\n$systemctl restart docker\n```\n\n重启后使用`docker info`命令可获得 docker 的所有相关信息,可以确认 docker 的`cgroup driver`已经换成了`systemd`。\n\n```bash\n$ docker info\n\n...\nLogging Driver: json-file\nCgroup Driver: systemd\nCgroup Version: 1\n...\n\n```\n\n此时再确认 kubelet 的状态可以看到 kubelet 已经自动重启并正常运行。","slug":"Kubernetes集群搭建","published":1,"layout":"post","photos":[],"link":"","_id":"cl2354nig00019eu7h84n2geu","content":"<p>这次打算尝试使用<code>kubeadm</code>来从头搭建一个<code>Kubernetes集群</code>，并且记录下整个过程以及中途遇到的问题。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>这次的搭建需要两台虚拟机，一台作为<code>Master节点</code>而另一台作为<code>Node节点</code>方便后续进行更多的集群相关的测试。</p>\n<p>云服务器：</p>\n<ul>\n<li>  AWS t2.large(2vCPU 8GiB) *2</li>\n</ul>\n<p>搭建工具：</p>\n<ul>\n<li>  kubeadm</li>\n</ul>\n<p>kubeadm 是一个可以帮助一键搭建 Kubernetes 集群的工具。</p>\n<h1 id=\"搭建-Master-节点\"><a href=\"#搭建-Master-节点\" class=\"headerlink\" title=\"搭建 Master 节点\"></a>搭建 Master 节点</h1><h2 id=\"1-安装-kubeadm-以及相关工具\"><a href=\"#1-安装-kubeadm-以及相关工具\" class=\"headerlink\" title=\"#1 安装 kubeadm 以及相关工具\"></a>#1 安装 kubeadm 以及相关工具</h2><p>首先需要配置云服务器，安装需要的工具。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> gnupg\n<span class=\"token variable\">$curl</span> -s https://packages.cloud.google.com/apt/doc/apt-key.gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -\nOK<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要将 Kubernetes 官方源添加到本地。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list\ndeb http:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>将以上文件（/etc/apt/sources.list.d/kubernetes.list）添加了之后，运行以下命令可以看到此时 Kubernetes 的源已经被添加进来。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n\n<span class=\"token punctuation\">..</span>.\nGet:4 https://packages.cloud.google.com/apt kubernetes-xenial InRelease <span class=\"token punctuation\">[</span><span class=\"token number\">9383</span> B<span class=\"token punctuation\">]</span>\nGet:6 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 Packages <span class=\"token punctuation\">[</span><span class=\"token number\">49.4</span> kB<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在完成了以上的配置之后即可开始安装<code>kubelet</code>，<code>kubectl</code>以及<code>kubeadm</code></p>\n<p><code>kubeadm</code>需要使用<code>kubelet</code>服务来以容器方式部署和启动 Kubernetes 的主要服务，所以需要安装并先启动 kubelet 服务。<br>而<code>kubectl</code>则是客户端命令行工具，在集群搭建完成之后可以通过它查看集群信息与状态。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 安装kubelet，kubectl以及kubeadm</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> kubelet kubectl kubeadm<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>要启动 kubelet 需要先安装并启动<code>docker</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$curl</span> -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -\nOK\n\n<span class=\"token comment\"># 要安装了 software-properties-common 才能使用 add-apt-repository</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> software-properties-common\n<span class=\"token variable\">$sudo</span> add-apt-repository <span class=\"token punctuation\">\\</span>\n<span class=\"token string\">\"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \\\n<span class=\"token variable\"><span class=\"token variable\">$(</span>lsb_release -cs<span class=\"token variable\">)</span></span> \\\nstable\"</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token comment\"># 安装docker</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成了以上所需工具的安装后就可以开始按顺序启动它们。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#启动docker</span>\n<span class=\"token variable\">$systemctl</span> start docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在 docker正常启动并确定docker的<code>cgroup driver</code>为<code>systemd</code>后（详情可见<code>错误及解决方案 #2</code>），可开始安装<code>Master节点</code>。</p>\n<p>此时如果用<code>systemctl status kubelet</code>命令查看<code>kubelet</code>状态，可发现kubelet没有正常启动，报错为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;Failed to load kubelet config file&quot; err&#x3D;&quot;failed to load Kubelet config file...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这是因为还没有运行 <code>kubeadm init</code>命令，在这个命令运行了之后，<code>kubelet</code>的配置文件会被生成，<code>kubelet</code>也会自动重启并正常运行。</p>\n<h2 id=\"2-使用-kubeadm-安装-Master-节点\"><a href=\"#2-使用-kubeadm-安装-Master-节点\" class=\"headerlink\" title=\"#2 使用 kubeadm 安装 Master 节点\"></a>#2 使用 kubeadm 安装 Master 节点</h2><p>使用<code>kubeadm config</code>命令打印<code>kubeadm</code>的默认配置.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#输出kubeadm默认配置</span>\n<span class=\"token variable\">$kubeadm</span> config print init-defaults\n<span class=\"token comment\">#将kubeadm默认配置保存到文件中方便做自定义修改</span>\n<span class=\"token variable\">$kubeadm</span> config print init-defaults <span class=\"token operator\">>></span> init.default.yaml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下是<code>kubeadm</code>打印出来的默认配置:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#init.default.yaml\napiVersion: kubeadm.k8s.io&#x2F;v1beta3\nbootstrapTokens:\n\n-   groups:\n    -   system:bootstrappers:kubeadm:default-node-token\n        token: abcdef.0123456789abcdef\n        ttl: 24h0m0s\n        usages:\n    -   signing\n    -   authentication\n        kind: InitConfiguration\n        localAPIEndpoint:\n        advertiseAddress: 1.2.3.4\n        bindPort: 6443\n        nodeRegistration:\n        criSocket: &#x2F;var&#x2F;run&#x2F;dockershim.sock\n        imagePullPolicy: IfNotPresent\n        name: node\n        taints: null\n\n---\n\napiServer:\ntimeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io&#x2F;v1beta3\ncertificatesDir: &#x2F;etc&#x2F;kubernetes&#x2F;pki\nclusterName: kubernetes\ncontrollerManager: &#123;&#125;\ndns: &#123;&#125;\netcd:\nlocal:\ndataDir: &#x2F;var&#x2F;lib&#x2F;etcd\nimageRepository: k8s.gcr.io\nkind: ClusterConfiguration\nkubernetesVersion: 1.22.0\nnetworking:\ndnsDomain: cluster.local\nserviceSubnet: 10.96.0.0&#x2F;12\nscheduler: &#123;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用以下命令可以查看镜像列表:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubeadm</span> config images list\nk8s.gcr.io/kube-apiserver:v1.22.1\nk8s.gcr.io/kube-controller-manager:v1.22.1\nk8s.gcr.io/kube-scheduler:v1.22.1\nk8s.gcr.io/kube-proxy:v1.22.1\nk8s.gcr.io/pause:3.5\nk8s.gcr.io/etcd:3.5.0-0\nk8s.gcr.io/coredns/coredns:v1.8.4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以使用<code>kubeadm config images pull</code>命令将这些镜像提前拉下来。就算不提前拉取，在后续步骤运行<code>kubeadm init</code>命令的时候也会自动进行拉取。</p>\n<p>使用以下命令就可直接安装 Master 节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> kubeadm init --pod-network-cidr<span class=\"token operator\">=</span><span class=\"token number\">172.30</span>.0.0/16<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这里注意一定要加上后面的<code>—pod-network-cidr</code>参数，否则在安装 flannel（网络插件）时会报以下错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">E0913 19:45:12.323393 1 main.go:293] Error registering network: failed to acquire lease: node &quot;ip-172-31-40-163&quot; pod cidr not assigned<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这次我没有修改默认的配置，如果有自定义配置，可以运行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> kubeadm init –config<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>config_file_path<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>安装完成后会得到以下相关提示:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Your Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\nmkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nAlternatively, if you are the root user, you can run:\n\nexport KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\nhttps:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据提示可以运行以下命令，这些命令是为了方便用户通过<code>kubectl</code>访问集群，<code>config</code>文件里配置了访问集群的入口，用户以及 token 等。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$mkdir</span> -p <span class=\"token environment constant\">$HOME</span>/.kube\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">cp</span> -i /etc/kubernetes/admin.conf <span class=\"token environment constant\">$HOME</span>/.kube/config\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">chown</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">id</span> -u<span class=\"token variable\">)</span></span><span class=\"token builtin class-name\">:</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">id</span> -g<span class=\"token variable\">)</span></span> <span class=\"token environment constant\">$HOME</span>/.kube/config<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>完成配置后就可以使用 kubectl 访问集群了。</p>\n<p>使用<code>kubectl get node</code>可以看到，目前<code>master node</code>的状态是<code>Not Ready</code>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">NAME             STATUS     ROLES                AGE    VERSION\nip-172-31-40-163 NotReady   control-plane,master 14m    v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用<code>kubectl get node &lt;node_name&gt; -o yaml</code>(或者<code>kubectl describe node &lt;node_name&gt;</code>)可以查看具体原因：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\n<span class=\"token key atrule\">message</span><span class=\"token punctuation\">:</span> 'container runtime network not ready<span class=\"token punctuation\">:</span> NetworkReady=false reason<span class=\"token punctuation\">:</span>NetworkPluginNotReady\n<span class=\"token key atrule\">message:docker</span><span class=\"token punctuation\">:</span> <span class=\"token key atrule\">network plugin is not ready</span><span class=\"token punctuation\">:</span> cni config uninitialized'\n<span class=\"token key atrule\">reason</span><span class=\"token punctuation\">:</span> KubeletNotReady\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"False\"</span>\n<span class=\"token punctuation\">...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是由于<code>kubeadm</code>的安装过程<strong>不涉及</strong><code>网络插件（CNI)</code>的初始化，所以集群没有网络功能。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> get pod --all-namespaces\nNAMESPACE   NAME                        READY   STATUS  RESTARTS AGE\nkube-system coredns-78fcd69978-59b4t     <span class=\"token number\">0</span>/1     Pending <span class=\"token number\">0</span>       10m\nkube-system coredns-78fcd69978-hc8qn     <span class=\"token number\">0</span>/1     Pending <span class=\"token number\">0</span>       10m\nkube-system etcd-ip-172-31-40-163        <span class=\"token number\">1</span>/1     Running <span class=\"token number\">3</span>       10m\nkube-system kube-apiserver-ip-172-<span class=\"token punctuation\">..</span>.    <span class=\"token number\">1</span>/1     Running <span class=\"token number\">2</span>       10m\nkube-system kube-controller-manager-<span class=\"token punctuation\">..</span>.  <span class=\"token number\">1</span>/1     Running <span class=\"token number\">2</span>       10m\nkube-system kube-proxy-dzklf             <span class=\"token number\">1</span>/1     Running <span class=\"token number\">0</span>       10m\nkube-system kube-scheduler-ip-172-<span class=\"token punctuation\">..</span>.    <span class=\"token number\">1</span>/1     Running <span class=\"token number\">3</span>       10m<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以观察到<code>kubadm</code>已经为<code>master 节点</code>启动了<code>coredns</code>,<code>etcd</code>,<code>kube-apiserver</code>,<code>kube-controller-manager</code>,<code>kube-proxy</code>以及 <code>kube-scheduler</code>了。<br>并且与网络相关<code>coredns</code>由于没有网络也无法正常启动。</p>\n<h2 id=\"3-安装网络插件-Flannel\"><a href=\"#3-安装网络插件-Flannel\" class=\"headerlink\" title=\"#3 安装网络插件 Flannel\"></a>#3 安装网络插件 Flannel</h2><p>首先下载在 Kubernetes 集群内安装<code>flanner</code>所需的配置文件，里面包括了启动该服务所需的所有资源的配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>使用下载的 Yaml 文件在集群内启动所有相关资源</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> apply -f kube-flannel.yml\n\npodsecuritypolicy.policy/psp.flannel.unprivileged created\nclusterrole.rbac.authorization.k8s.io/flannel created\nclusterrolebinding.rbac.authorization.k8s.io/flannel created\nserviceaccount/flannel created\nconfigmap/kube-flannel-cfg created\ndaemonset.apps/kube-flannel-ds created<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>现在查看<code>pod</code>的状态可以发现所有的<code>pod</code>都正常运行(<code>Running</code>)中</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl get pod --all-namespaces\nNAMESPACE NAME READY STATUS RESTARTS AGE\nkube-system coredns-78fcd69978-xx27f <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system coredns-78fcd69978-zxnw5 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system etcd-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">4</span> 3m54s\nkube-system kube-apiserver-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">3</span> 3m54s\nkube-system kube-controller-manager-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m57s\nkube-system kube-flannel-ds-26tcn <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 5s\nkube-system kube-proxy-8c4md <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system kube-scheduler-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">4</span> 3m54s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而<code>master 节点</code>也切换到了<code>Ready</code>的状态</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl get node\nNAME                STATUS  ROLES                   AGE     VERSION\nip-172-31-40-163    Ready   control-plane,master    4m47s   v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"搭建-Node-节点\"><a href=\"#搭建-Node-节点\" class=\"headerlink\" title=\"搭建 Node 节点\"></a>搭建 Node 节点</h1><p>重复以上在<code>Master节点</code>中安装<code>kubeadm</code>等工具的过程。</p>\n<p>运行<code>kubeadm</code>在<code>Master 节点</code>安装完成后返回的将<code>worker 节点</code>加入集群的命令:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubeadm</span> <span class=\"token function\">join</span> <span class=\"token number\">172.31</span>.40.163:6443 --token 61gwee.be4wj16mlyjsahaj <span class=\"token punctuation\">\\</span>\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果在创建 <code>Master节点</code>后忘记了以上命令及token，则可用<code>kubeadm token create --print-join-command</code>命令重新生成token并输出完整的<code>join</code>命令。</p>\n<p>在以上命令成功运行后，在<code>Master节点</code>通过<code>kubectl get node</code>可观察到，集群已有两个节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> get node\n\nNAME               STATUS   ROLES                  AGE   VERSION\nip-172-31-40-163   Ready    control-plane,master   23h   v1.22.1\nip-172-31-47-241   Ready    <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>                 15s   v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"错误及解决方案\"><a href=\"#错误及解决方案\" class=\"headerlink\" title=\"错误及解决方案\"></a>错误及解决方案</h1><h2 id=\"1-docker-连接-Docker-daemon-socket-失败\"><a href=\"#1-docker-连接-Docker-daemon-socket-失败\" class=\"headerlink\" title=\"#1 docker 连接 Docker daemon socket 失败\"></a>#1 docker 连接 Docker daemon socket 失败</h2><p>运行<code>docker info</code>命令时得到以下错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ERROR: Got permission denied while trying to connect to the Docker daemon socket ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>需要确认 docker 组已经创建并且当前使用的用户在这个组内。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">groupadd</span> docker\n<span class=\"token variable\">$sudo</span> gpasswd -a <span class=\"token operator\">&lt;</span>username<span class=\"token operator\">></span> docker\n<span class=\"token variable\">$newgrp</span> docker\n<span class=\"token variable\">$systemctl</span> restart docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成以上步骤后，再次运行<code>docker info</code>命令可以正确得到所需信息。</p>\n<h2 id=\"2-Kubelet-启动失败\"><a href=\"#2-Kubelet-启动失败\" class=\"headerlink\" title=\"#2 Kubelet 启动失败\"></a>#2 Kubelet 启动失败</h2><p>用<code>systemctl status kubelet</code>命令获得进程号后，再用<code>journalctl \\_PID=&lt;进程号&gt;|vim – </code>查看日志，获得了以下信息：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Sep <span class=\"token number\">13</span> <span class=\"token number\">17</span>:30:09 ip-172-31-40-163 kubelet<span class=\"token punctuation\">[</span><span class=\"token number\">18094</span><span class=\"token punctuation\">]</span>: E0913 <span class=\"token number\">17</span>:30:09.620375 <span class=\"token number\">18094</span> server.go:294<span class=\"token punctuation\">]</span> <span class=\"token string\">\"Failed to run kubelet\"</span> <span class=\"token assign-left variable\">err</span><span class=\"token operator\">=</span><span class=\"token string\">\"failed to run Kubelet: misconfiguration: kubelet cgroup driver: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>systemd<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> is different from docker cgroup driver: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>cgroupfs<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>原因是<code>docker</code>和<code>kubelet</code>使用的<code>cgroup driver</code>不一样，一个是<code>systemd</code>，一个是<code>cgroupfs</code>。根据 Kubernetes 官网文档：</p>\n<blockquote>\n<p><code>systemd driver</code> is <strong>recommended</strong> for <code>kubeadm</code> based setups instead of the <code>cgroupfs driver</code>, because kubeadm manages the kubelet as a systemd service.</p>\n</blockquote>\n<p><code>systemd</code>是比较推荐的,也是 kubeadm 默认设置的 cgroup drive。（据说 systemd 更安全）所以这里我统一设置成使用 systemd。也就是需要把 <code>docker</code> 的<code>cgroup driver</code>更改成<code>systemd</code></p>\n<p>修改<code>/etc/docker/daemon.json</code>（或创建）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#&#x2F;etc&#x2F;docker&#x2F;daemon.json\n&#123;\n&quot;exec-opts&quot;:[&quot;native.cgroupdriver&#x3D;systemd&quot;]\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在完成修改之后，用以下命令更新配置并重启 docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$systemctl</span> daemon-reload\n<span class=\"token variable\">$systemctl</span> restart docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>重启后使用<code>docker info</code>命令可获得 docker 的所有相关信息,可以确认 docker 的<code>cgroup driver</code>已经换成了<code>systemd</code>。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker info\n\n<span class=\"token punctuation\">..</span>.\nLogging Driver: json-file\nCgroup Driver: systemd\nCgroup Version: <span class=\"token number\">1</span>\n<span class=\"token punctuation\">..</span>.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时再确认 kubelet 的状态可以看到 kubelet 已经自动重启并正常运行。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这次打算尝试使用<code>kubeadm</code>来从头搭建一个<code>Kubernetes集群</code>，并且记录下整个过程以及中途遇到的问题。</p>\n<h1 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h1><p>这次的搭建需要两台虚拟机，一台作为<code>Master节点</code>而另一台作为<code>Node节点</code>方便后续进行更多的集群相关的测试。</p>\n<p>云服务器：</p>\n<ul>\n<li>  AWS t2.large(2vCPU 8GiB) *2</li>\n</ul>\n<p>搭建工具：</p>\n<ul>\n<li>  kubeadm</li>\n</ul>\n<p>kubeadm 是一个可以帮助一键搭建 Kubernetes 集群的工具。</p>\n<h1 id=\"搭建-Master-节点\"><a href=\"#搭建-Master-节点\" class=\"headerlink\" title=\"搭建 Master 节点\"></a>搭建 Master 节点</h1><h2 id=\"1-安装-kubeadm-以及相关工具\"><a href=\"#1-安装-kubeadm-以及相关工具\" class=\"headerlink\" title=\"#1 安装 kubeadm 以及相关工具\"></a>#1 安装 kubeadm 以及相关工具</h2><p>首先需要配置云服务器，安装需要的工具。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> gnupg\n<span class=\"token variable\">$curl</span> -s https://packages.cloud.google.com/apt/doc/apt-key.gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -\nOK<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>需要将 Kubernetes 官方源添加到本地。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#&#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;kubernetes.list\ndeb http:&#x2F;&#x2F;apt.kubernetes.io&#x2F; kubernetes-xenial main<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>将以上文件（/etc/apt/sources.list.d/kubernetes.list）添加了之后，运行以下命令可以看到此时 Kubernetes 的源已经被添加进来。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n\n<span class=\"token punctuation\">..</span>.\nGet:4 https://packages.cloud.google.com/apt kubernetes-xenial InRelease <span class=\"token punctuation\">[</span><span class=\"token number\">9383</span> B<span class=\"token punctuation\">]</span>\nGet:6 https://packages.cloud.google.com/apt kubernetes-xenial/main amd64 Packages <span class=\"token punctuation\">[</span><span class=\"token number\">49.4</span> kB<span class=\"token punctuation\">]</span>\n<span class=\"token punctuation\">..</span>.<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在完成了以上的配置之后即可开始安装<code>kubelet</code>，<code>kubectl</code>以及<code>kubeadm</code></p>\n<p><code>kubeadm</code>需要使用<code>kubelet</code>服务来以容器方式部署和启动 Kubernetes 的主要服务，所以需要安装并先启动 kubelet 服务。<br>而<code>kubectl</code>则是客户端命令行工具，在集群搭建完成之后可以通过它查看集群信息与状态。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\"># 安装kubelet，kubectl以及kubeadm</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> kubelet kubectl kubeadm<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>要启动 kubelet 需要先安装并启动<code>docker</code></p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$curl</span> -fsSL https://mirrors.ustc.edu.cn/docker-ce/linux/debian/gpg <span class=\"token operator\">|</span> <span class=\"token function\">sudo</span> apt-key <span class=\"token function\">add</span> -\nOK\n\n<span class=\"token comment\"># 要安装了 software-properties-common 才能使用 add-apt-repository</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> software-properties-common\n<span class=\"token variable\">$sudo</span> add-apt-repository <span class=\"token punctuation\">\\</span>\n<span class=\"token string\">\"deb [arch=amd64] https://mirrors.ustc.edu.cn/docker-ce/linux/debian \\\n<span class=\"token variable\"><span class=\"token variable\">$(</span>lsb_release -cs<span class=\"token variable\">)</span></span> \\\nstable\"</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> update\n<span class=\"token comment\"># 安装docker</span>\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">apt-get</span> <span class=\"token function\">install</span> docker-ce<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成了以上所需工具的安装后就可以开始按顺序启动它们。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#启动docker</span>\n<span class=\"token variable\">$systemctl</span> start docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>在 docker正常启动并确定docker的<code>cgroup driver</code>为<code>systemd</code>后（详情可见<code>错误及解决方案 #2</code>），可开始安装<code>Master节点</code>。</p>\n<p>此时如果用<code>systemctl status kubelet</code>命令查看<code>kubelet</code>状态，可发现kubelet没有正常启动，报错为：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">&quot;Failed to load kubelet config file&quot; err&#x3D;&quot;failed to load Kubelet config file...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n<p>这是因为还没有运行 <code>kubeadm init</code>命令，在这个命令运行了之后，<code>kubelet</code>的配置文件会被生成，<code>kubelet</code>也会自动重启并正常运行。</p>\n<h2 id=\"2-使用-kubeadm-安装-Master-节点\"><a href=\"#2-使用-kubeadm-安装-Master-节点\" class=\"headerlink\" title=\"#2 使用 kubeadm 安装 Master 节点\"></a>#2 使用 kubeadm 安装 Master 节点</h2><p>使用<code>kubeadm config</code>命令打印<code>kubeadm</code>的默认配置.</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token comment\">#输出kubeadm默认配置</span>\n<span class=\"token variable\">$kubeadm</span> config print init-defaults\n<span class=\"token comment\">#将kubeadm默认配置保存到文件中方便做自定义修改</span>\n<span class=\"token variable\">$kubeadm</span> config print init-defaults <span class=\"token operator\">>></span> init.default.yaml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>以下是<code>kubeadm</code>打印出来的默认配置:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#init.default.yaml\napiVersion: kubeadm.k8s.io&#x2F;v1beta3\nbootstrapTokens:\n\n-   groups:\n    -   system:bootstrappers:kubeadm:default-node-token\n        token: abcdef.0123456789abcdef\n        ttl: 24h0m0s\n        usages:\n    -   signing\n    -   authentication\n        kind: InitConfiguration\n        localAPIEndpoint:\n        advertiseAddress: 1.2.3.4\n        bindPort: 6443\n        nodeRegistration:\n        criSocket: &#x2F;var&#x2F;run&#x2F;dockershim.sock\n        imagePullPolicy: IfNotPresent\n        name: node\n        taints: null\n\n---\n\napiServer:\ntimeoutForControlPlane: 4m0s\napiVersion: kubeadm.k8s.io&#x2F;v1beta3\ncertificatesDir: &#x2F;etc&#x2F;kubernetes&#x2F;pki\nclusterName: kubernetes\ncontrollerManager: &#123;&#125;\ndns: &#123;&#125;\netcd:\nlocal:\ndataDir: &#x2F;var&#x2F;lib&#x2F;etcd\nimageRepository: k8s.gcr.io\nkind: ClusterConfiguration\nkubernetesVersion: 1.22.0\nnetworking:\ndnsDomain: cluster.local\nserviceSubnet: 10.96.0.0&#x2F;12\nscheduler: &#123;&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>用以下命令可以查看镜像列表:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubeadm</span> config images list\nk8s.gcr.io/kube-apiserver:v1.22.1\nk8s.gcr.io/kube-controller-manager:v1.22.1\nk8s.gcr.io/kube-scheduler:v1.22.1\nk8s.gcr.io/kube-proxy:v1.22.1\nk8s.gcr.io/pause:3.5\nk8s.gcr.io/etcd:3.5.0-0\nk8s.gcr.io/coredns/coredns:v1.8.4<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以使用<code>kubeadm config images pull</code>命令将这些镜像提前拉下来。就算不提前拉取，在后续步骤运行<code>kubeadm init</code>命令的时候也会自动进行拉取。</p>\n<p>使用以下命令就可直接安装 Master 节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> kubeadm init --pod-network-cidr<span class=\"token operator\">=</span><span class=\"token number\">172.30</span>.0.0/16<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这里注意一定要加上后面的<code>—pod-network-cidr</code>参数，否则在安装 flannel（网络插件）时会报以下错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">E0913 19:45:12.323393 1 main.go:293] Error registering network: failed to acquire lease: node &quot;ip-172-31-40-163&quot; pod cidr not assigned<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>这次我没有修改默认的配置，如果有自定义配置，可以运行</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> kubeadm init –config<span class=\"token operator\">=</span><span class=\"token operator\">&lt;</span>config_file_path<span class=\"token operator\">></span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>安装完成后会得到以下相关提示:</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">Your Kubernetes control-plane has initialized successfully!\n\nTo start using your cluster, you need to run the following as a regular user:\n\nmkdir -p $HOME&#x2F;.kube\n  sudo cp -i &#x2F;etc&#x2F;kubernetes&#x2F;admin.conf $HOME&#x2F;.kube&#x2F;config\n  sudo chown $(id -u):$(id -g) $HOME&#x2F;.kube&#x2F;config\n\nAlternatively, if you are the root user, you can run:\n\nexport KUBECONFIG&#x3D;&#x2F;etc&#x2F;kubernetes&#x2F;admin.conf\n\nYou should now deploy a pod network to the cluster.\nRun &quot;kubectl apply -f [podnetwork].yaml&quot; with one of the options listed at:\nhttps:&#x2F;&#x2F;kubernetes.io&#x2F;docs&#x2F;concepts&#x2F;cluster-administration&#x2F;addons&#x2F;\n\nThen you can join any number of worker nodes by running the following on each as root:\n\nkubeadm join 172.31.40.163:6443 --token 61gwee.be4wj16mlyjsahaj \\\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>根据提示可以运行以下命令，这些命令是为了方便用户通过<code>kubectl</code>访问集群，<code>config</code>文件里配置了访问集群的入口，用户以及 token 等。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$mkdir</span> -p <span class=\"token environment constant\">$HOME</span>/.kube\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">cp</span> -i /etc/kubernetes/admin.conf <span class=\"token environment constant\">$HOME</span>/.kube/config\n<span class=\"token variable\">$sudo</span> <span class=\"token function\">chown</span> <span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">id</span> -u<span class=\"token variable\">)</span></span><span class=\"token builtin class-name\">:</span><span class=\"token variable\"><span class=\"token variable\">$(</span><span class=\"token function\">id</span> -g<span class=\"token variable\">)</span></span> <span class=\"token environment constant\">$HOME</span>/.kube/config<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<p>完成配置后就可以使用 kubectl 访问集群了。</p>\n<p>使用<code>kubectl get node</code>可以看到，目前<code>master node</code>的状态是<code>Not Ready</code>。</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">NAME             STATUS     ROLES                AGE    VERSION\nip-172-31-40-163 NotReady   control-plane,master 14m    v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>使用<code>kubectl get node &lt;node_name&gt; -o yaml</code>(或者<code>kubectl describe node &lt;node_name&gt;</code>)可以查看具体原因：</p>\n<pre class=\"line-numbers language-yaml\" data-language=\"yaml\"><code class=\"language-yaml\"><span class=\"token punctuation\">...</span>\n<span class=\"token key atrule\">message</span><span class=\"token punctuation\">:</span> 'container runtime network not ready<span class=\"token punctuation\">:</span> NetworkReady=false reason<span class=\"token punctuation\">:</span>NetworkPluginNotReady\n<span class=\"token key atrule\">message:docker</span><span class=\"token punctuation\">:</span> <span class=\"token key atrule\">network plugin is not ready</span><span class=\"token punctuation\">:</span> cni config uninitialized'\n<span class=\"token key atrule\">reason</span><span class=\"token punctuation\">:</span> KubeletNotReady\n<span class=\"token key atrule\">status</span><span class=\"token punctuation\">:</span> <span class=\"token string\">\"False\"</span>\n<span class=\"token punctuation\">...</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>这是由于<code>kubeadm</code>的安装过程<strong>不涉及</strong><code>网络插件（CNI)</code>的初始化，所以集群没有网络功能。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> get pod --all-namespaces\nNAMESPACE   NAME                        READY   STATUS  RESTARTS AGE\nkube-system coredns-78fcd69978-59b4t     <span class=\"token number\">0</span>/1     Pending <span class=\"token number\">0</span>       10m\nkube-system coredns-78fcd69978-hc8qn     <span class=\"token number\">0</span>/1     Pending <span class=\"token number\">0</span>       10m\nkube-system etcd-ip-172-31-40-163        <span class=\"token number\">1</span>/1     Running <span class=\"token number\">3</span>       10m\nkube-system kube-apiserver-ip-172-<span class=\"token punctuation\">..</span>.    <span class=\"token number\">1</span>/1     Running <span class=\"token number\">2</span>       10m\nkube-system kube-controller-manager-<span class=\"token punctuation\">..</span>.  <span class=\"token number\">1</span>/1     Running <span class=\"token number\">2</span>       10m\nkube-system kube-proxy-dzklf             <span class=\"token number\">1</span>/1     Running <span class=\"token number\">0</span>       10m\nkube-system kube-scheduler-ip-172-<span class=\"token punctuation\">..</span>.    <span class=\"token number\">1</span>/1     Running <span class=\"token number\">3</span>       10m<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>可以观察到<code>kubadm</code>已经为<code>master 节点</code>启动了<code>coredns</code>,<code>etcd</code>,<code>kube-apiserver</code>,<code>kube-controller-manager</code>,<code>kube-proxy</code>以及 <code>kube-scheduler</code>了。<br>并且与网络相关<code>coredns</code>由于没有网络也无法正常启动。</p>\n<h2 id=\"3-安装网络插件-Flannel\"><a href=\"#3-安装网络插件-Flannel\" class=\"headerlink\" title=\"#3 安装网络插件 Flannel\"></a>#3 安装网络插件 Flannel</h2><p>首先下载在 Kubernetes 集群内安装<code>flanner</code>所需的配置文件，里面包括了启动该服务所需的所有资源的配置</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$wget</span> https://raw.githubusercontent.com/coreos/flannel/master/Documentation/kube-flannel.yml<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>使用下载的 Yaml 文件在集群内启动所有相关资源</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> apply -f kube-flannel.yml\n\npodsecuritypolicy.policy/psp.flannel.unprivileged created\nclusterrole.rbac.authorization.k8s.io/flannel created\nclusterrolebinding.rbac.authorization.k8s.io/flannel created\nserviceaccount/flannel created\nconfigmap/kube-flannel-cfg created\ndaemonset.apps/kube-flannel-ds created<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>现在查看<code>pod</code>的状态可以发现所有的<code>pod</code>都正常运行(<code>Running</code>)中</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl get pod --all-namespaces\nNAMESPACE NAME READY STATUS RESTARTS AGE\nkube-system coredns-78fcd69978-xx27f <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system coredns-78fcd69978-zxnw5 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system etcd-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">4</span> 3m54s\nkube-system kube-apiserver-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">3</span> 3m54s\nkube-system kube-controller-manager-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m57s\nkube-system kube-flannel-ds-26tcn <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 5s\nkube-system kube-proxy-8c4md <span class=\"token number\">1</span>/1 Running <span class=\"token number\">0</span> 3m40s\nkube-system kube-scheduler-ip-172-31-40-163 <span class=\"token number\">1</span>/1 Running <span class=\"token number\">4</span> 3m54s<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>而<code>master 节点</code>也切换到了<code>Ready</code>的状态</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ kubectl get node\nNAME                STATUS  ROLES                   AGE     VERSION\nip-172-31-40-163    Ready   control-plane,master    4m47s   v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"搭建-Node-节点\"><a href=\"#搭建-Node-节点\" class=\"headerlink\" title=\"搭建 Node 节点\"></a>搭建 Node 节点</h1><p>重复以上在<code>Master节点</code>中安装<code>kubeadm</code>等工具的过程。</p>\n<p>运行<code>kubeadm</code>在<code>Master 节点</code>安装完成后返回的将<code>worker 节点</code>加入集群的命令:</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubeadm</span> <span class=\"token function\">join</span> <span class=\"token number\">172.31</span>.40.163:6443 --token 61gwee.be4wj16mlyjsahaj <span class=\"token punctuation\">\\</span>\n --discovery-token-ca-cert-hash sha256:97ea59547a4cca2fbcf62360b3561c6e27dd4e1a294533505490391dab872daf<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>如果在创建 <code>Master节点</code>后忘记了以上命令及token，则可用<code>kubeadm token create --print-join-command</code>命令重新生成token并输出完整的<code>join</code>命令。</p>\n<p>在以上命令成功运行后，在<code>Master节点</code>通过<code>kubectl get node</code>可观察到，集群已有两个节点：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$kubectl</span> get node\n\nNAME               STATUS   ROLES                  AGE   VERSION\nip-172-31-40-163   Ready    control-plane,master   23h   v1.22.1\nip-172-31-47-241   Ready    <span class=\"token operator\">&lt;</span>none<span class=\"token operator\">></span>                 15s   v1.22.1<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<h1 id=\"错误及解决方案\"><a href=\"#错误及解决方案\" class=\"headerlink\" title=\"错误及解决方案\"></a>错误及解决方案</h1><h2 id=\"1-docker-连接-Docker-daemon-socket-失败\"><a href=\"#1-docker-连接-Docker-daemon-socket-失败\" class=\"headerlink\" title=\"#1 docker 连接 Docker daemon socket 失败\"></a>#1 docker 连接 Docker daemon socket 失败</h2><p>运行<code>docker info</code>命令时得到以下错误：</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">ERROR: Got permission denied while trying to connect to the Docker daemon socket ...<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>需要确认 docker 组已经创建并且当前使用的用户在这个组内。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$sudo</span> <span class=\"token function\">groupadd</span> docker\n<span class=\"token variable\">$sudo</span> gpasswd -a <span class=\"token operator\">&lt;</span>username<span class=\"token operator\">></span> docker\n<span class=\"token variable\">$newgrp</span> docker\n<span class=\"token variable\">$systemctl</span> restart docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>完成以上步骤后，再次运行<code>docker info</code>命令可以正确得到所需信息。</p>\n<h2 id=\"2-Kubelet-启动失败\"><a href=\"#2-Kubelet-启动失败\" class=\"headerlink\" title=\"#2 Kubelet 启动失败\"></a>#2 Kubelet 启动失败</h2><p>用<code>systemctl status kubelet</code>命令获得进程号后，再用<code>journalctl \\_PID=&lt;进程号&gt;|vim – </code>查看日志，获得了以下信息：</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">Sep <span class=\"token number\">13</span> <span class=\"token number\">17</span>:30:09 ip-172-31-40-163 kubelet<span class=\"token punctuation\">[</span><span class=\"token number\">18094</span><span class=\"token punctuation\">]</span>: E0913 <span class=\"token number\">17</span>:30:09.620375 <span class=\"token number\">18094</span> server.go:294<span class=\"token punctuation\">]</span> <span class=\"token string\">\"Failed to run kubelet\"</span> <span class=\"token assign-left variable\">err</span><span class=\"token operator\">=</span><span class=\"token string\">\"failed to run Kubelet: misconfiguration: kubelet cgroup driver: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>systemd<span class=\"token entity\" title=\"\\&quot;\">\\\"</span> is different from docker cgroup driver: <span class=\"token entity\" title=\"\\&quot;\">\\\"</span>cgroupfs<span class=\"token entity\" title=\"\\&quot;\">\\\"</span>\"</span><span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span></span></code></pre>\n\n<p>原因是<code>docker</code>和<code>kubelet</code>使用的<code>cgroup driver</code>不一样，一个是<code>systemd</code>，一个是<code>cgroupfs</code>。根据 Kubernetes 官网文档：</p>\n<blockquote>\n<p><code>systemd driver</code> is <strong>recommended</strong> for <code>kubeadm</code> based setups instead of the <code>cgroupfs driver</code>, because kubeadm manages the kubelet as a systemd service.</p>\n</blockquote>\n<p><code>systemd</code>是比较推荐的,也是 kubeadm 默认设置的 cgroup drive。（据说 systemd 更安全）所以这里我统一设置成使用 systemd。也就是需要把 <code>docker</code> 的<code>cgroup driver</code>更改成<code>systemd</code></p>\n<p>修改<code>/etc/docker/daemon.json</code>（或创建）</p>\n<pre class=\"line-numbers language-none\"><code class=\"language-none\">#&#x2F;etc&#x2F;docker&#x2F;daemon.json\n&#123;\n&quot;exec-opts&quot;:[&quot;native.cgroupdriver&#x3D;systemd&quot;]\n&#125;<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>在完成修改之后，用以下命令更新配置并重启 docker</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"><span class=\"token variable\">$systemctl</span> daemon-reload\n<span class=\"token variable\">$systemctl</span> restart docker<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span></span></code></pre>\n\n<p>重启后使用<code>docker info</code>命令可获得 docker 的所有相关信息,可以确认 docker 的<code>cgroup driver</code>已经换成了<code>systemd</code>。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">$ docker info\n\n<span class=\"token punctuation\">..</span>.\nLogging Driver: json-file\nCgroup Driver: systemd\nCgroup Version: <span class=\"token number\">1</span>\n<span class=\"token punctuation\">..</span>.\n<span aria-hidden=\"true\" class=\"line-numbers-rows\"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>\n\n<p>此时再确认 kubelet 的状态可以看到 kubelet 已经自动重启并正常运行。</p>\n"}],"PostAsset":[],"PostCategory":[],"PostTag":[{"post_id":"cl2354nig00019eu7h84n2geu","tag_id":"cl2354nij00039eu70c74czgh","_id":"cl2354nil00049eu7d54t888p"}],"Tag":[{"name":"Kubernetes","_id":"cl2354nij00039eu70c74czgh"}]}}